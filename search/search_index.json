{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ams-bp","title":"AMS-BP","text":""},{"location":"#advanced-fluorescence-microscopy-simulation-tool","title":"Advanced Fluorescence Microscopy Simulation Tool","text":"<p>AMS-BP is a powerful simulation tool for advanced fluorescence microscopy experiments. This guide covers both command-line usage and library integration.</p>"},{"location":"#overview-of-simulation-workflow","title":"Overview of Simulation Workflow","text":"<p>A ground truth is created, a, with (<code>f_{n}</code>\\) fluorophore types of (<code>N_{f_{n}}</code>\\) molecules each. If applicable, the motion of these molecules is modelled using a 3D bounded FBM with fluctuating generalized diffusion coefficients and Hurst parameters. Variations are modelled as a Markov Chain and require rate constants as parameters. Different fluorophores can have different motion models. The resolution of the motion models is (<code>\\Delta t</code>\\) and cannot be smaller than 1 ms (for computational efficiency). Given the microscope parameters specific to the experimental procedure to simulate, at every time (<code>t_{j}</code>\\), the excitation intensity for each channel (b) is calculated at each fluorophore's location, c. For (<code>t_{j} \\rightarrow t_{j+\\Delta t}</code>\\), the photophysical state trajectory of the fluorophore is simulated using the light intensity at the molecule's location as input for any light-dependent transition rates, d. For the duration that the shutter is open and light is emitted from the sample, emission filters for each channel are applied before the convolution with PSF models, e. The incident photons on the detector are then converted to photoelectrons and finally to digital units using the detector models provided, f.</p>"},{"location":"#api-reference-and-docs","title":"API Reference and Docs","text":"<p>Find detailed API references for the library at: joemans3/github.io/AMS_BP</p> <p>A more detailed example is provided in the jupyter notebook in the examples. For starters refer to the VisualizingIndividualModules. Then head over to the laser modulation module which will show how to change the laser power over time in the simulations. Then view an example of a complex experiment setup for FRAP which is possible by the use of compositions of modules in this simulation library.</p>"},{"location":"#examples-click-on-the-image-buttons-to-be-taken-to-the-jupyter-notebooks","title":"Examples (Click on the image buttons to be taken to the Jupyter notebooks):","text":"<p>!!ATTENTION!! - Please note that you NEED to install the developmental dependencies to run the examples in full. This is mainly for installing the Jupyter notebook extensions, matplotlib and other visualization packages.</p> <p> </p> <p> </p> <p></p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Command Line Interface</li> <li>GUI</li> <li>Configuration File</li> <li>Running Experiments</li> <li>Advanced Usage</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#installing-the-cli-tool-using-uv","title":"Installing the CLI tool using UV","text":"<ol> <li>Install UV.</li> <li>Run the command:</li> </ol> <pre><code>uv tool install AMS_BP\n</code></pre> <ol> <li>You will have access to three CLI commands (using the uv interface):<ul> <li><code>run_AMS_BP runsim</code> : This is the main entry point for the simulation. (see <code>run_AMS_BP runsim --help</code> for more details)</li> <li><code>run_AMS_BP config</code> : This is a helper tool to generate a template config file for the simulation. (see <code>run_AMS_BP config --help</code> for more details)</li> <li><code>run_AMS_BP gui</code> : to start the GUI. See GUI Documentation</li> <li>Note: using <code>run_AMS_BP --help</code> will show you all the available commands.</li> </ul> </li> <li>You can now use these tools (they are isolated in their own env created by uv, which is cool).</li> </ol>"},{"location":"#pypi","title":"PyPi","text":"<ol> <li>If using pip, make sure the environment is python &gt;= 3.12</li> <li>Run:</li> </ol> <pre><code>pip install AMS_BP\n</code></pre>"},{"location":"#command-line-interface","title":"Command Line Interface","text":"<p>AMS-BP provides a command-line interface with three main commands:</p> <pre><code># Generate a default configuration file\nrun_AMS_BP config [OPTIONS]\n\n# Run a simulation using a configuration file\nrun_AMS_BP runsim CONFIG_FILE\n\n#start the GUI\nrun_AMS_BP gui\n</code></pre>"},{"location":"#config-command-options","title":"Config Command Options","text":"<ul> <li><code>-o, --output_path PATH</code>: Specify the output directory for the configuration file</li> <li><code>-r, --recursive_o</code>: Create output directory if it doesn't exist</li> </ul>"},{"location":"#gui","title":"GUI","text":"<p>In addition to the CLI and programmatic API, AMS-BP comes with a graphical interface to guide users through the configuration, simulation, and analysis pipeline.</p>"},{"location":"#main-gui-features","title":"Main GUI Features","text":"<p>The GUI provides the following tools from a single interface:</p> <ul> <li>Create Configuration File \u2014 Launches the visual configuration builder</li> <li>Run Simulation from Config \u2014 Select a .toml file and run the simulation with logging and progress tracking</li> <li>Visualize Microscopy Data (Napari) \u2014 Open TIFF, PNG, ND2, or Zarr image files and view with the Napari viewer</li> <li>Package Logs for Sharing \u2014 Package run directories (e.g., run_2024_04_20_001) into a .zip file for archival or collaboration</li> </ul>"},{"location":"#launch-the-gui","title":"Launch the GUI","text":"<p>To start the GUI, run:</p> <pre><code>\nrun_AMS_BP gui\n</code></pre> <p>For detailed walkthrough see the GUI Documentation.</p>"},{"location":"#configuration-file","title":"Configuration File","text":"<p>The configuration file (sim_config.toml) is divided into several key sections:</p>"},{"location":"#for-a-detailed-description-of-the-configuration-file-refer-to-the-configuration-file-reference","title":"For a detailed description of the configuration file, refer to the Configuration File Reference.","text":""},{"location":"#basic-units","title":"Basic Units","text":"<pre><code>version = \"0.1\"\nlength_unit = \"um\"        # micrometers\ntime_unit = \"ms\"          # milliseconds\ndiffusion_unit = \"um^2/s\" # diffusion coefficient units\n</code></pre>"},{"location":"#key-configuration-sections","title":"Key Configuration Sections","text":"<ol> <li>Cell Parameters</li> <li> <p>Define cell space dimensions</p> </li> <li> <p>Molecule Parameters</p> </li> <li>Number of molecules per type</li> <li>Tracking types (constant/fbm)</li> <li>Diffusion coefficients</li> <li> <p>State transition probabilities</p> </li> <li> <p>Global Parameters</p> </li> <li>Sample plane dimensions</li> <li>Cycle count -&gt; Exposure time + Interval time</li> <li> <p>Exposure and interval times</p> </li> <li> <p>Fluorophore Configuration</p> </li> <li>Any number of fluorophores</li> <li>Any number of States per fluorophore</li> <li>Fluorophore StateType: (bright, dark, bleached) -&gt; All States must be one of these.</li> <li>Transition parameters</li> <li> <p>Spectral properties</p> </li> <li> <p>Optical Configuration</p> </li> <li>PSF parameters</li> <li>Laser settings</li> <li>Channel configuration</li> <li>Camera settings</li> </ol>"},{"location":"#running-experiments","title":"Running Experiments","text":"<p>AMS-BP's CLI currently supports two types of experiments:</p> <p>(however this can be extended when used as a library) </p>"},{"location":"#1-time-series","title":"1. Time Series","text":"<pre><code>[experiment]\nexperiment_type = \"time-series\"\nz_position = 0.0\nlaser_names_active = [\"red\", \"blue\"]\nlaser_powers_active = [0.5, 0.05]\nlaser_positions_active = [[5, 5, 0], [5, 5, 0]]\n</code></pre>"},{"location":"#2-z-stack","title":"2. Z-Stack","text":"<pre><code>[experiment]\nexperiment_type = \"z-stack\"\nz_position = [-0.5, -0.4, -0.3, -0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.4, 0.5]\nlaser_names_active = [\"red\", \"blue\"]\nlaser_powers_active = [0.5, 0.05]\nlaser_positions_active = [[5, 5, 0], [5, 5, 0]]\n</code></pre> <p>To run the default configuration: 1. Make sure you followed the uv tool installation. 2. Make a copy of the default configuration file using the command:</p> <pre><code>run_AMS_BP config\n</code></pre> <ol> <li>Run the sim:</li> </ol> <pre><code>run_AMS_BP runsim sim_config.toml\n</code></pre> <ol> <li>View the results in the newly created folder, whose name is defined in the config file.</li> </ol>"},{"location":"#high-priority-features","title":"High Priority Features","text":"<p>~~1. Irregular cell shapes with motion models~~ (supported with release of v0.2.0) 2. Stimulated Emission models 3. STORM workflow examples 4. CTRW motion models 5. Simpler configurations</p> <p>NOTE: Please note that this application DOES NOT currently model the process of stimulated emission, and as such is not suitable for simulating stimulated emission microscopy (STED)-type experiments. Work in this area is ongoing.</p>"},{"location":"#custom-experiment-types","title":"Custom Experiment Types","text":"<p>When using AMS-BP as a library, you can create custom experiment types by:</p> <ol> <li>Extending the base experiment class</li> <li>Implementing custom scanning patterns</li> <li>Defining new molecule behaviors</li> <li>Creating specialized analysis routines</li> </ol>"},{"location":"#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Configuration Management</li> <li>Keep separate config files for different experiment types</li> <li>Version control your configurations</li> <li> <p>Document any custom modifications</p> </li> <li> <p>Resource Usage</p> </li> <li>Monitor memory usage for large simulations</li> <li> <p>Use appropriate sampling rates</p> </li> <li> <p>Data Output</p> </li> <li>Set appropriate output paths</li> <li>Use meaningful naming conventions</li> <li>Consider data format requirements for analysis</li> </ol>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and their solutions: TODO</p>"},{"location":"API_Documentation/main_cli/","title":"Main cli","text":""},{"location":"API_Documentation/main_cli/#ams_bp-cli-api-reference","title":"AMS_BP CLI API Reference","text":""},{"location":"API_Documentation/main_cli/#module-main_clipy","title":"Module: <code>main_cli.py</code>","text":"<p>This module provides the command-line interface for the AMS_BP package.</p>"},{"location":"API_Documentation/main_cli/#dependencies","title":"Dependencies","text":"<pre><code>import shutil\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\nimport rich\nimport typer\nfrom PyQt6.QtWidgets import QApplication\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\nfrom typing_extensions import Annotated\n\nfrom . import __version__\nfrom .gui.main import MainWindow\nfrom .run_sim_util import run_simulation_from_file\n</code></pre>"},{"location":"API_Documentation/main_cli/#main-application-object","title":"Main Application Object","text":""},{"location":"API_Documentation/main_cli/#typer_app_asms_bp","title":"<code>typer_app_asms_bp</code>","text":"<p>The main Typer application instance that defines the CLI.</p> <pre><code>typer_app_asms_bp = typer.Typer(\n    name=\"AMS_BP CLI Tool\",\n    help=cli_help_doc,\n    short_help=\"CLI tool for AMS_BP.\",\n    rich_markup_mode=\"rich\",\n    pretty_exceptions_show_locals=False,\n    add_completion=False,\n    no_args_is_help=True,\n    context_settings={\"help_option_names\": [\"-h\", \"--help\"]},\n)\n</code></pre>"},{"location":"API_Documentation/main_cli/#functions","title":"Functions","text":""},{"location":"API_Documentation/main_cli/#cell_simulation","title":"<code>cell_simulation()</code>","text":"<p>Description: Callback function that displays version information when the CLI is invoked without a specific command.</p> <p>Usage: Automatically called when running the CLI without commands.</p> <p>Returns: None</p> <p>Example:</p> <pre><code>python -m main_cli\n</code></pre>"},{"location":"API_Documentation/main_cli/#run_gui-none","title":"<code>run_gui() -&gt; None</code>","text":"<p>Description: Starts the PyQt GUI for the AMS_BP application.</p> <p>Parameters: None</p> <p>Returns: None</p> <p>Example:</p> <pre><code>python -m main_cli gui\n</code></pre>"},{"location":"API_Documentation/main_cli/#generate_configoutput_path-path-path-output_path_make_recursive-optionalbool-none-none","title":"<code>generate_config(output_path: Path = Path(\".\"), output_path_make_recursive: Optional[bool] = None) -&gt; None</code>","text":"<p>Description: Generates a sample configuration file for the cell simulation.</p> <p>Parameters: - <code>output_path</code>: Path where the configuration file will be saved.   - Type: <code>Path</code>   - Default: Current directory (<code>Path(\".\")</code>)   - CLI Option: <code>--output_path, -o</code></p> <ul> <li><code>output_path_make_recursive</code>: Whether to create the output directory if it doesn't exist.</li> <li>Type: <code>Optional[bool]</code></li> <li>Default: <code>None</code></li> <li>CLI Option: <code>--recursive_o, -r</code></li> </ul> <p>Returns: None</p> <p>Raises: - <code>typer.Abort</code>: If there's an error creating the configuration file or the output directory.</p> <p>Example:</p> <pre><code>python -m main_cli config --output_path /path/to/directory --recursive_o\n</code></pre>"},{"location":"API_Documentation/main_cli/#run_cell_simulationconfig_file-path-none","title":"<code>run_cell_simulation(config_file: Path) -&gt; None</code>","text":"<p>Description: Runs the cell simulation using the provided configuration file.</p> <p>Parameters: - <code>config_file</code>: Path to the configuration file.   - Type: <code>Path</code>   - Required: Yes   - CLI Argument: First positional argument</p> <p>Returns: None</p> <p>Example:</p> <pre><code>python -m main_cli runsim path/to/config.toml\n</code></pre>"},{"location":"API_Documentation/main_cli/#validate_configconfig-dict-none","title":"<code>validate_config(config: dict) -&gt; None</code>","text":"<p>Description: Validates that the configuration dictionary has the required structure.</p> <p>Parameters: - <code>config</code>: Configuration dictionary to validate.   - Type: <code>dict</code>   - Required: Yes</p> <p>Returns: None</p> <p>Raises: - <code>typer.Abort</code>: If the configuration doesn't have the required structure.</p> <p>Internal Details: - Checks for the presence of an <code>Output_Parameters</code> section - Checks for the presence of an <code>output_path</code> field within the <code>Output_Parameters</code> section</p>"},{"location":"API_Documentation/main_cli/#cli-commands","title":"CLI Commands","text":"Command Description Arguments Options <code>config</code> Generate sample configuration file - <code>--output_path, -o</code>: Output directory<code>--recursive_o, -r</code>: Create directories if they don't exist <code>runsim</code> Run cell simulation <code>CONFIG_FILE</code>: Path to config file - <code>gui</code> Start the PyQt GUI - -"},{"location":"API_Documentation/main_cli/#import-and-use-in-other-code","title":"Import and Use in Other Code","text":"<p>To use this CLI as a module in other Python code:</p> <pre><code>from ams_bp.main_cli import typer_app_asms_bp, generate_config, run_cell_simulation, run_gui\n\n# Generate a config file\ngenerate_config(Path(\"/path/to/output\"), True)\n\n# Run a simulation\nrun_cell_simulation(Path(\"/path/to/config.toml\"))\n\n# Run the GUI\nrun_gui()\n</code></pre>"},{"location":"API_Documentation/main_cli/#related-files","title":"Related Files","text":"<ul> <li><code>run_sim_util.py</code>: Contains the <code>run_simulation_from_file()</code> function used by the <code>runsim</code> command</li> <li><code>gui/main.py</code>: Contains the <code>MainWindow</code> class used by the <code>gui</code> command</li> <li><code>sim_config.toml</code>: Template configuration file that gets copied when using the <code>config</code> command</li> </ul>"},{"location":"API_Documentation/sim_config/","title":"Sim config","text":""},{"location":"API_Documentation/sim_config/#simulation-configuration-file-documentation","title":"Simulation Configuration File Documentation","text":"<p>This document provides a detailed explanation of the TOML configuration file used for setting up a simulation. The configuration file is structured into several sections, each defining specific parameters for the simulation. Below is a breakdown of each section and its parameters.</p>"},{"location":"API_Documentation/sim_config/#1-general-configuration","title":"1. General Configuration","text":""},{"location":"API_Documentation/sim_config/#version","title":"<code>version</code>","text":"<ul> <li>Type: String</li> <li>Pattern: <code>^\\d+\\.\\d+$</code></li> <li>Description: Specifies the version of the configuration file format.</li> </ul>"},{"location":"API_Documentation/sim_config/#length_unit","title":"<code>length_unit</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"um\"]</code></li> <li>Description: The unit of length used throughout the simulation. Always set to <code>\"um\"</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#time_unit","title":"<code>time_unit</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"ms\"]</code></li> <li>Description: The unit of time used throughout the simulation. Always set to <code>\"ms\"</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#diffusion_unit","title":"<code>diffusion_unit</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"um^2/s\"]</code></li> <li>Description: The unit of diffusion coefficient used throughout the simulation. Always set to <code>\"um^2/s\"</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#2-cell-parameters","title":"2. Cell Parameters","text":""},{"location":"API_Documentation/sim_config/#cell_type","title":"<code>cell_type</code>","text":"<ul> <li>Type: Union[str, CellType]</li> <li>Description: Defines the type of the cell to simulate.</li> <li>Supported: RectangularCell, SphericalCell, OvoidCell, RodCell, BuddingCell</li> </ul>"},{"location":"API_Documentation/sim_config/#params","title":"<code>params</code>","text":"<ul> <li>Type: dictionary of parameter names (String) and values (Any)</li> <li>Description: Values for the cell_type specified above. The following the general structure:</li> </ul> <pre><code># SphericalCell\nparams = {\n    \"center\": [0, 0, 0],   # 3D center coordinates\n    \"radius\": 10.0         # Radius of sphere\n}\n</code></pre> <pre><code># RodCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"direction\": [0, 0, 1],    # Direction vector (will be normalized)\n    \"height\": 20.0,            # Length of the rod\n    \"radius\": 5.0              # Radius of the rod\n}\n</code></pre> <pre><code># RectangularCell\nparams = {\n    \"bounds\": [-10, 10, -10, 10, -10, 10]  # [xmin, xmax, ymin, ymax, zmin, zmax]\n}\n</code></pre> <pre><code># OvoidCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"xradius\": 10.0,           # Radius in x-direction\n    \"yradius\": 15.0,           # Radius in y-direction\n    \"zradius\": 20.0            # Radius in z-direction\n}\n</code></pre>"},{"location":"API_Documentation/sim_config/#3-molecule-parameters","title":"3. Molecule Parameters","text":""},{"location":"API_Documentation/sim_config/#num_molecules","title":"<code>num_molecules</code>","text":"<ul> <li>Type: Array of Integers</li> <li>Description: Specifies the number of molecules for each type. The length of this array determines the number of molecule types.</li> </ul>"},{"location":"API_Documentation/sim_config/#track_type","title":"<code>track_type</code>","text":"<ul> <li>Type: Array of Strings</li> <li>Enum: <code>[\"constant\", \"fbm\"]</code></li> <li>Description: Defines the type of trajectory for each molecule type.</li> </ul>"},{"location":"API_Documentation/sim_config/#diffusion_coefficient","title":"<code>diffusion_coefficient</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: Specifies the diffusion coefficients for each molecule type in <code>um^2/s</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#diffusion_track_amount","title":"<code>diffusion_track_amount</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: Defines the initial distribution of diffusion coefficients for trajectories.</li> </ul>"},{"location":"API_Documentation/sim_config/#hurst_exponent","title":"<code>hurst_exponent</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: Specifies the Hurst exponent for each molecule type.</li> </ul>"},{"location":"API_Documentation/sim_config/#hurst_track_amount","title":"<code>hurst_track_amount</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: Defines the initial distribution of Hurst exponents for trajectories.</li> </ul>"},{"location":"API_Documentation/sim_config/#allow_transition_probability","title":"<code>allow_transition_probability</code>","text":"<ul> <li>Type: Array of Booleans</li> <li>Description: Determines whether transition probabilities are allowed for each molecule type.</li> </ul>"},{"location":"API_Documentation/sim_config/#transition_matrix_time_step","title":"<code>transition_matrix_time_step</code>","text":"<ul> <li>Type: Array of Integers</li> <li>Description: The time step in milliseconds (<code>ms</code>) at which transition probabilities are applied.</li> </ul>"},{"location":"API_Documentation/sim_config/#diffusion_transition_matrix","title":"<code>diffusion_transition_matrix</code>","text":"<ul> <li>Type: Array of Arrays of Arrays of Numbers</li> <li>Description: The transition matrix for diffusion coefficients.</li> </ul>"},{"location":"API_Documentation/sim_config/#hurst_transition_matrix","title":"<code>hurst_transition_matrix</code>","text":"<ul> <li>Type: Array of Arrays of Arrays of Numbers</li> <li>Description: The transition matrix for Hurst exponents.</li> </ul>"},{"location":"API_Documentation/sim_config/#state_probability_diffusion","title":"<code>state_probability_diffusion</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: The probability distribution for diffusion states.</li> </ul>"},{"location":"API_Documentation/sim_config/#state_probability_hurst","title":"<code>state_probability_hurst</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Description: The probability distribution for Hurst states.</li> </ul>"},{"location":"API_Documentation/sim_config/#4-global-parameters","title":"4. Global Parameters","text":""},{"location":"API_Documentation/sim_config/#sample_plane_dim","title":"<code>sample_plane_dim</code>","text":"<ul> <li>Type: Array of Numbers</li> <li>Shape: <code>[width, height]</code></li> <li>Description: The dimensions of the sample plane in micrometers (<code>um</code>).</li> </ul>"},{"location":"API_Documentation/sim_config/#cycle_count","title":"<code>cycle_count</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The number of cycles of exposure and interval time.</li> </ul>"},{"location":"API_Documentation/sim_config/#exposure_time","title":"<code>exposure_time</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The exposure time in milliseconds (<code>ms</code>).</li> </ul>"},{"location":"API_Documentation/sim_config/#interval_time","title":"<code>interval_time</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The interval time in milliseconds (<code>ms</code>).</li> </ul>"},{"location":"API_Documentation/sim_config/#oversample_motion_time","title":"<code>oversample_motion_time</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The oversampling time for motion in milliseconds (<code>ms</code>).</li> </ul>"},{"location":"API_Documentation/sim_config/#5-condensate-parameters","title":"5. Condensate Parameters","text":""},{"location":"API_Documentation/sim_config/#initial_centers","title":"<code>initial_centers</code>","text":"<ul> <li>Type: Array of Array of Arrays of Numbers</li> <li>Shape: <code>[[[x, y, z], ...], ...]</code></li> <li>Description: The initial centers of condensates in micrometers (<code>um</code>). The first dimension is the types of different molecules. Similarr to the <code>num_molecules</code> array in the molecule parameters.</li> </ul>"},{"location":"API_Documentation/sim_config/#initial_scale","title":"<code>initial_scale</code>","text":"<ul> <li>Type: Array of Array of Numbers</li> <li>Description: The initial scale of condensates in micrometers (<code>um</code>).</li> </ul>"},{"location":"API_Documentation/sim_config/#diffusion_coefficient_1","title":"<code>diffusion_coefficient</code>","text":"<ul> <li>Type: Array of Array of Numbers</li> <li>Description: The diffusion coefficients of condensates in <code>um^2/s</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#hurst_exponent_1","title":"<code>hurst_exponent</code>","text":"<ul> <li>Type: Array of Array of Numbers</li> <li>Description: The Hurst exponents of condensates.</li> </ul>"},{"location":"API_Documentation/sim_config/#density_dif","title":"<code>density_dif</code>","text":"<ul> <li>Type: Array of Number</li> <li>Description: The density difference between the condensate and the background.</li> </ul>"},{"location":"API_Documentation/sim_config/#6-output-parameters","title":"6. Output Parameters","text":""},{"location":"API_Documentation/sim_config/#output_path","title":"<code>output_path</code>","text":"<ul> <li>Type: String</li> <li>Description: The path where the output files will be saved. Can be absolute or relative.</li> </ul>"},{"location":"API_Documentation/sim_config/#output_name","title":"<code>output_name</code>","text":"<ul> <li>Type: String</li> <li>Description: The name of the output file.</li> </ul>"},{"location":"API_Documentation/sim_config/#subsegment_type","title":"<code>subsegment_type</code>","text":"<ul> <li>Type: String</li> <li>Description: The type of subsegmentation to be applied. Currently not implemented.</li> </ul>"},{"location":"API_Documentation/sim_config/#subsegment_number","title":"<code>subsegment_number</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The number of subsegments. Currently not implemented.</li> </ul>"},{"location":"API_Documentation/sim_config/#7-fluorophores","title":"7. Fluorophores","text":""},{"location":"API_Documentation/sim_config/#num_of_fluorophores","title":"<code>num_of_fluorophores</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The number of fluorophores in the simulation.</li> </ul>"},{"location":"API_Documentation/sim_config/#fluorophore_names","title":"<code>fluorophore_names</code>","text":"<ul> <li>Type: Array of Strings</li> <li>Description: The names of the fluorophores.</li> </ul>"},{"location":"API_Documentation/sim_config/#fluorophore-specific-parameters","title":"Fluorophore-Specific Parameters","text":"<p>Each fluorophore has its own section with the following parameters:</p>"},{"location":"API_Documentation/sim_config/#name","title":"<code>name</code>","text":"<ul> <li>Type: String</li> <li>Description: The name of the fluorophore.</li> </ul>"},{"location":"API_Documentation/sim_config/#initial_state","title":"<code>initial_state</code>","text":"<ul> <li>Type: String</li> <li>Condition: One of the states defined in the <code>states</code> section.</li> <li>Description: The initial state of the fluorophore. </li> </ul>"},{"location":"API_Documentation/sim_config/#states","title":"States","text":"<p>Each fluorophore has states defined with the following parameters:</p> <ul> <li><code>name</code>: The name of the state.</li> <li><code>state_type</code>: The type of state (<code>fluorescent</code>, <code>dark</code>, <code>bleached</code>).</li> <li><code>quantum_yield</code>: The quantum yield of the state (0-1).</li> <li><code>extinction_coefficient</code>: The extinction coefficient in <code>M^-1 cm^-1</code>.</li> <li><code>fluorescent_lifetime</code>: The fluorescent lifetime in seconds.</li> <li><code>excitation_spectrum</code>: The excitation spectrum with <code>wavelengths</code> and <code>intensities</code>.</li> <li><code>emission_spectrum</code>: The emission spectrum with <code>wavelengths</code> and <code>intensities</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#transitions","title":"Transitions","text":"<p>Each fluorophore has transitions defined with the following parameters:</p> <ul> <li><code>from_state</code>: The starting state of the transition.</li> <li><code>to_state</code>: The target state of the transition.</li> <li><code>photon_dependent</code>: Whether the transition is photon-dependent.</li> <li><code>spectrum</code>: The spectrum associated with the transition, including <code>wavelengths</code>, <code>intensities</code>, <code>extinction_coefficient</code>, and <code>quantum_yield</code>.</li> <li><code>base_rate</code>: The base rate of the transition in <code>1/s</code>.</li> </ul>"},{"location":"API_Documentation/sim_config/#8-psf-point-spread-function","title":"8. PSF (Point Spread Function)","text":""},{"location":"API_Documentation/sim_config/#type","title":"<code>type</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"gaussian\"]</code></li> <li>Description: The type of PSF.</li> </ul>"},{"location":"API_Documentation/sim_config/#custom_path","title":"<code>custom_path</code>","text":"<ul> <li>Type: String</li> <li>Description: The path to a custom PSF file. Currently not supported.</li> </ul>"},{"location":"API_Documentation/sim_config/#parameters","title":"<code>parameters</code>","text":"<ul> <li>Type: Object</li> <li>Properties:</li> <li><code>numerical_aperture</code>: The numerical aperture (typical range: 0.1 - 1.5).</li> <li><code>refractive_index</code>: The refractive index (default is air: 1.0).</li> <li><code>pinhole_diameter</code>: None or float. In units of um. None = no pinhole before the detector.</li> </ul>"},{"location":"API_Documentation/sim_config/#9-lasers","title":"9. Lasers","text":""},{"location":"API_Documentation/sim_config/#active","title":"<code>active</code>","text":"<ul> <li>Type: Array of Strings</li> <li>Description: The list of active lasers.</li> </ul>"},{"location":"API_Documentation/sim_config/#laser-specific-parameters","title":"Laser-Specific Parameters","text":"<p>Each laser has its own section with the following parameters:</p>"},{"location":"API_Documentation/sim_config/#type_1","title":"<code>type</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"widefield\", \"gaussian\", \"hilo\"]</code></li> <li>Description: The type of laser.</li> </ul>"},{"location":"API_Documentation/sim_config/#preset","title":"<code>preset</code>","text":"<ul> <li>Type: String</li> <li>Description: The preset name of the laser.</li> </ul>"},{"location":"API_Documentation/sim_config/#parameters_1","title":"<code>parameters</code>","text":"<ul> <li>Type: Object</li> <li>Properties:</li> <li><code>power</code>: The power of the laser in watts.</li> <li><code>wavelength</code>: The wavelength in nanometers.</li> <li><code>beam_width</code>: The beam width in micrometers.</li> <li><code>numerical_aperture</code>: The numerical aperture.</li> <li><code>refractive_index</code>: The refractive index.</li> <li><code>inclination_angle</code>: The inclination angle in degrees (only for HiLo).</li> </ul>"},{"location":"API_Documentation/sim_config/#10-channels","title":"10. Channels","text":""},{"location":"API_Documentation/sim_config/#num_of_channels","title":"<code>num_of_channels</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The number of channels.</li> </ul>"},{"location":"API_Documentation/sim_config/#channel_names","title":"<code>channel_names</code>","text":"<ul> <li>Type: Array of Strings</li> <li>Description: The names of the channels.</li> </ul>"},{"location":"API_Documentation/sim_config/#split_efficiency","title":"<code>split_efficiency</code>","text":"<ul> <li>Type: Array of Numbers</li> <li>Description: The efficiency of the channel splitter for each channel (0-1).</li> </ul>"},{"location":"API_Documentation/sim_config/#filter-set-configuration","title":"Filter Set Configuration","text":"<p>Each channel has its own filter set with the following parameters:</p>"},{"location":"API_Documentation/sim_config/#filter_set_name","title":"<code>filter_set_name</code>","text":"<ul> <li>Type: String</li> <li>Description: The name of the filter set.</li> </ul>"},{"location":"API_Documentation/sim_config/#filter_set_description","title":"<code>filter_set_description</code>","text":"<ul> <li>Type: String</li> <li>Description: The description of the filter set.</li> </ul>"},{"location":"API_Documentation/sim_config/#excitation","title":"<code>excitation</code>","text":"<ul> <li>Type: Object</li> <li>Properties:</li> <li><code>name</code>: The name of the excitation filter.</li> <li><code>type</code>: The type of filter (<code>allow_all</code>).</li> <li><code>points</code>: The number of points in the filter.</li> </ul>"},{"location":"API_Documentation/sim_config/#emission","title":"<code>emission</code>","text":"<ul> <li>Type: Object</li> <li>Properties:</li> <li><code>name</code>: The name of the emission filter.</li> <li><code>type</code>: The type of filter (<code>bandpass</code>).</li> <li><code>center_wavelength</code>: The center wavelength in nanometers.</li> <li><code>bandwidth</code>: The bandwidth in nanometers.</li> <li><code>transmission_peak</code>: The transmission peak (0-1).</li> <li><code>points</code>: The number of points in the filter.</li> </ul>"},{"location":"API_Documentation/sim_config/#11-camera","title":"11. Camera","text":""},{"location":"API_Documentation/sim_config/#type_2","title":"<code>type</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"CMOS\"]</code></li> <li>Description: The type of camera.</li> </ul>"},{"location":"API_Documentation/sim_config/#pixel_count","title":"<code>pixel_count</code>","text":"<ul> <li>Type: Array of Integers</li> <li>Shape: <code>[width, height]</code></li> <li>Description: The number of pixels in the camera.</li> </ul>"},{"location":"API_Documentation/sim_config/#pixel_detector_size","title":"<code>pixel_detector_size</code>","text":"<ul> <li>Type: Number</li> <li>Description: The size of each pixel detector in micrometers.</li> </ul>"},{"location":"API_Documentation/sim_config/#magnification","title":"<code>magnification</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The magnification of the camera.</li> </ul>"},{"location":"API_Documentation/sim_config/#dark_current","title":"<code>dark_current</code>","text":"<ul> <li>Type: Number</li> <li>Description: The dark current in electrons per pixel per second.</li> </ul>"},{"location":"API_Documentation/sim_config/#readout_noise","title":"<code>readout_noise</code>","text":"<ul> <li>Type: Number</li> <li>Description: The readout noise in electrons RMS.</li> </ul>"},{"location":"API_Documentation/sim_config/#bit_depth","title":"<code>bit_depth</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The bit depth of the camera.</li> </ul>"},{"location":"API_Documentation/sim_config/#sensitivity","title":"<code>sensitivity</code>","text":"<ul> <li>Type: Number</li> <li>Description: The sensitivity of the camera in electrons per ADU.</li> </ul>"},{"location":"API_Documentation/sim_config/#base_adu","title":"<code>base_adu</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The base ADU value.</li> </ul>"},{"location":"API_Documentation/sim_config/#binning_size","title":"<code>binning_size</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The binning size (e.g., 1x1 or 2x2).</li> </ul>"},{"location":"API_Documentation/sim_config/#quantum_efficiency","title":"<code>quantum_efficiency</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Shape: <code>[[wavelength, efficiency], ...]</code></li> <li>Description: The quantum efficiency curve of the camera.</li> </ul>"},{"location":"API_Documentation/sim_config/#12-experiment","title":"12. Experiment","text":""},{"location":"API_Documentation/sim_config/#name_1","title":"<code>name</code>","text":"<ul> <li>Type: String</li> <li>Description: The name of the experiment.</li> </ul>"},{"location":"API_Documentation/sim_config/#description","title":"<code>description</code>","text":"<ul> <li>Type: String</li> <li>Description: The description of the experiment.</li> </ul>"},{"location":"API_Documentation/sim_config/#experiment_type","title":"<code>experiment_type</code>","text":"<ul> <li>Type: String</li> <li>Enum: <code>[\"time-series\", \"z-stack\"]</code></li> <li>Description: The type of experiment.</li> </ul>"},{"location":"API_Documentation/sim_config/#z_position","title":"<code>z_position</code>","text":"<ul> <li>Type: Array of Numbers, or Number ( if \"z-stack\" or \"time-series\")</li> <li>Description: The z-positions for the experiment.</li> </ul>"},{"location":"API_Documentation/sim_config/#laser_names_active","title":"<code>laser_names_active</code>","text":"<ul> <li>Type: Array of Strings</li> <li>Description: The names of active lasers.</li> </ul>"},{"location":"API_Documentation/sim_config/#laser_powers_active","title":"<code>laser_powers_active</code>","text":"<ul> <li>Type: Array of Numbers</li> <li>Description: The powers of active lasers in watts.</li> </ul>"},{"location":"API_Documentation/sim_config/#laser_positions_active","title":"<code>laser_positions_active</code>","text":"<ul> <li>Type: Array of Arrays of Numbers</li> <li>Shape: <code>[[x, y, z], ...]</code></li> <li>Description: The positions of active lasers in micrometers.</li> </ul>"},{"location":"API_Documentation/sim_config/#xyoffset","title":"<code>xyoffset</code>","text":"<ul> <li>Type: Array of Numbers</li> <li>Shape: <code>[x, y]</code></li> <li>Description: The x and y offsets in micrometers.</li> </ul>"},{"location":"API_Documentation/sim_config/#exposure_time_1","title":"<code>exposure_time</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The exposure time in milliseconds.</li> </ul>"},{"location":"API_Documentation/sim_config/#interval_time_1","title":"<code>interval_time</code>","text":"<ul> <li>Type: Integer</li> <li>Description: The interval time in milliseconds.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/","title":"Sim microscopy","text":""},{"location":"API_Documentation/core/sim_microscopy/#virtualmicroscope-module-documentation","title":"VirtualMicroscope Module Documentation","text":"<p>This module defines the <code>VirtualMicroscope</code> class and related utility classes and functions for simulating a virtual microscope. The module leverages various components such as cameras, lasers, sample planes, and photophysics to simulate imaging processes.</p>"},{"location":"API_Documentation/core/sim_microscopy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>VirtualMicroscope</p> </li> <li> <p>mapSampleCamera</p> </li> <li> <p>PhotonFrameContainer</p> </li> <li> <p>Utility Functions</p> </li> <li>generate_sampling_pattern</li> <li>timeValidator</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#virtualmicroscope","title":"VirtualMicroscope","text":"<p>The <code>VirtualMicroscope</code> class represents a virtual microscope that integrates various components to simulate imaging processes.</p>"},{"location":"API_Documentation/core/sim_microscopy/#attributes","title":"Attributes","text":"<ul> <li>camera: Tuple containing a <code>Detector</code> and <code>QuantumEfficiency</code> object.</li> <li>qe: Quantum efficiency of the camera.</li> <li>sample_plane: A <code>SamplePlane</code> object representing the sample being imaged.</li> <li>lasers: Dictionary of <code>LaserProfile</code> objects, keyed by laser names.</li> <li>channels: A <code>Channels</code> object representing the imaging channels.</li> <li>psf: A callable that generates a <code>PSFEngine</code> based on input parameters.</li> <li>_time: Current simulation time in milliseconds.</li> <li>config: A <code>ConfigList</code> object containing configuration parameters.</li> <li>initial_config: Cached initial configuration of the microscope.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#methods","title":"Methods","text":""},{"location":"API_Documentation/core/sim_microscopy/#__init__self-camera-tupledetector-quantumefficiency-sample_plane-sampleplane-lasers-dictstr-laserprofile-channels-channels-psf-callablefloat-int-optionalfloat-int-psfengine-config-configlist-start_time-int-0","title":"<code>__init__(self, camera: Tuple[Detector, QuantumEfficiency], sample_plane: SamplePlane, lasers: Dict[str, LaserProfile], channels: Channels, psf: Callable[[float | int, Optional[float | int]], PSFEngine], config: ConfigList, start_time: int = 0)</code>","text":"<p>Initializes the <code>VirtualMicroscope</code> with the provided components.</p>"},{"location":"API_Documentation/core/sim_microscopy/#_set_laser_position_center_cellself-none","title":"<code>_set_laser_position_center_cell(self) -&gt; None</code>","text":"<p>Centers the laser positions at the center of the sample plane.</p>"},{"location":"API_Documentation/core/sim_microscopy/#_cached_initial_configself-none","title":"<code>_cached_initial_config(self) -&gt; None</code>","text":"<p>Caches the initial configuration of the microscope.</p>"},{"location":"API_Documentation/core/sim_microscopy/#_set_laser_powersself-laser_power-dictstr-float-none","title":"<code>_set_laser_powers(self, laser_power: Dict[str, float]) -&gt; None</code>","text":"<p>Sets the power of the lasers. Raises a <code>ValueError</code> if the provided power exceeds the maximum allowed power.</p>"},{"location":"API_Documentation/core/sim_microscopy/#_set_laser_positionsself-laser_positions-dictstr-tuplefloat-float-float-none","title":"<code>_set_laser_positions(self, laser_positions: Dict[str, Tuple[float, float, float]]) -&gt; None</code>","text":"<p>Sets the positions of the lasers.</p>"},{"location":"API_Documentation/core/sim_microscopy/#run_simself-z_val-float-laser_powerdictstr-unionfloat-callablefloat-float-xyoffset-tuplefloat-float-laser_position-optionaldictstr-uniontuplefloat-float-float-callablefloat-tuplefloat-float-float-none-duration_total-optionalint-none-exposure_time-optionalint-none-interval_time-optionalint-none-scanning-optionalbool-false-tuplenpndarray-metadata","title":"<code>run_sim(self, z_val: float, laser_power:Dict[str, Union[float, Callable[[float], float]], xyoffset: Tuple[float, float], laser_position: Optional[Dict[str, Union[Tuple[float, float, float], Callable[[float], Tuple[float, float, float]]]]] = None, duration_total: Optional[int] = None, exposure_time: Optional[int] = None, interval_time: Optional[int] = None, scanning: Optional[bool] = False) -&gt; Tuple[np.ndarray, MetaData]</code>","text":"<p>Runs the simulation for the given parameters and returns the resulting image stack and metadata.</p>"},{"location":"API_Documentation/core/sim_microscopy/#reset_to_initial_configself-bool","title":"<code>reset_to_initial_config(self) -&gt; bool</code>","text":"<p>Resets the microscope to its initial configuration.</p>"},{"location":"API_Documentation/core/sim_microscopy/#mapsamplecamera","title":"mapSampleCamera","text":"<p>The <code>mapSampleCamera</code> class maps the location of the sample plane onto the detector grid.</p>"},{"location":"API_Documentation/core/sim_microscopy/#attributes_1","title":"Attributes","text":"<ul> <li>sampleplane: A <code>SamplePlane</code> object.</li> <li>camera: A <code>Detector</code> object.</li> <li>xyoffset: Tuple representing the offset in micrometers.</li> <li>frames: Number of frames to process.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#methods_1","title":"Methods","text":""},{"location":"API_Documentation/core/sim_microscopy/#__post_init__self","title":"<code>__post_init__(self)</code>","text":"<p>Initializes the <code>PhotonFrameContainer</code> with base frames.</p>"},{"location":"API_Documentation/core/sim_microscopy/#get_pixel_indicesself-x-float-y-float-tupleint-int","title":"<code>get_pixel_indices(self, x: float, y: float) -&gt; Tuple[int, int]</code>","text":"<p>Converts sample plane coordinates to detector grid indices.</p>"},{"location":"API_Documentation/core/sim_microscopy/#add_psf_frameself-psf-npndarray-mol_pos-tuplefloat-float-frame_num-int-none","title":"<code>add_psf_frame(self, psf: np.ndarray, mol_pos: Tuple[float, float], frame_num: int) -&gt; None</code>","text":"<p>Adds a PSF to the specified frame at the given molecular position.</p>"},{"location":"API_Documentation/core/sim_microscopy/#get_frameself-frame_num-int-npndarray","title":"<code>get_frame(self, frame_num: int) -&gt; np.ndarray</code>","text":"<p>Returns the specified frame.</p>"},{"location":"API_Documentation/core/sim_microscopy/#photonframecontainer","title":"PhotonFrameContainer","text":"<p>The <code>PhotonFrameContainer</code> class is a container for simulation frames.</p>"},{"location":"API_Documentation/core/sim_microscopy/#attributes_2","title":"Attributes","text":"<ul> <li>frames: List of <code>np.ndarray</code> representing the frames.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#methods_2","title":"Methods","text":""},{"location":"API_Documentation/core/sim_microscopy/#__iter__self","title":"<code>__iter__(self)</code>","text":"<p>Allows iteration over the frames.</p>"},{"location":"API_Documentation/core/sim_microscopy/#__len__self","title":"<code>__len__(self)</code>","text":"<p>Returns the number of frames.</p>"},{"location":"API_Documentation/core/sim_microscopy/#utility-functions","title":"Utility Functions","text":""},{"location":"API_Documentation/core/sim_microscopy/#generate_sampling_pattern","title":"generate_sampling_pattern","text":"<p>Generates a sampling pattern based on exposure and interval times.</p>"},{"location":"API_Documentation/core/sim_microscopy/#parameters","title":"Parameters","text":"<ul> <li>exposure_time: Duration of each exposure.</li> <li>interval_time: Duration between exposures.</li> <li>start_time: Beginning of the sampling period.</li> <li>end_time: End of the sampling period.</li> <li>oversample_motion_time: Time resolution for oversampling.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#returns","title":"Returns","text":"<ul> <li>times: List of sampling times.</li> <li>sample_bool: List indicating frame numbers or intervals.</li> <li>max_frame: Maximum frame number.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#timevalidator","title":"timeValidator","text":"<p>Validates the provided time parameters against the simulation constraints.</p>"},{"location":"API_Documentation/core/sim_microscopy/#parameters_1","title":"Parameters","text":"<ul> <li>oexposure_time: Original exposure time.</li> <li>ointerval_time: Original interval time.</li> <li>oversample_motion_time: Time resolution for oversampling.</li> <li>ototal_time: Original total time.</li> <li>current_time: Current simulation time.</li> <li>state_arr: Dictionary containing exposure, interval, and total time.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#returns_1","title":"Returns","text":"<ul> <li>duration_total: Validated total duration.</li> <li>exposure_time: Validated exposure time.</li> <li>interval_time: Validated interval time.</li> </ul>"},{"location":"API_Documentation/core/sim_microscopy/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the provided times are invalid.</li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/","title":"Configmodels","text":""},{"location":"API_Documentation/core/configio/configmodels/#configuration-models-documentation","title":"Configuration Models Documentation","text":""},{"location":"API_Documentation/core/configio/configmodels/#overview","title":"Overview","text":"<p>The configuration models module defines Pydantic BaseModel classes for validating and managing microscopy simulation parameters. Each model class represents a specific set of configuration parameters with built-in validation and type conversion.</p>"},{"location":"API_Documentation/core/configio/configmodels/#models","title":"Models","text":""},{"location":"API_Documentation/core/configio/configmodels/#cellparameters","title":"CellParameters","text":"<p>Defines the physical parameters of the cell being simulated.</p> <pre><code>class CellParameters(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields","title":"Fields","text":"<ul> <li><code>cell_type: Union[str, CellType]</code></li> <li>Type of cell. </li> <li> <p>Supported: RectangularCell, SphericalCell, OvoidCell, RodCell, BuddingCell</p> </li> <li> <p><code>params: Dict[str, Any]</code></p> </li> <li>Key value pairs of the parameters of the specified cell.</li> </ul> <pre><code># SphericalCell\nparams = {\n    \"center\": [0, 0, 0],   # 3D center coordinates\n    \"radius\": 10.0         # Radius of sphere\n}\n</code></pre> <pre><code># RodCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"direction\": [0, 0, 1],    # Direction vector (will be normalized)\n    \"height\": 20.0,            # Length of the rod\n    \"radius\": 5.0              # Radius of the rod\n}\n</code></pre> <pre><code># RectangularCell\nparams = {\n    \"bounds\": [-10, 10, -10, 10, -10, 10]  # [xmin, xmax, ymin, ymax, zmin, zmax]\n}\n</code></pre> <pre><code># OvoidCell\nparams = {\n    \"center\": [0, 0, 0],       # 3D center coordinates\n    \"direction\": [0, 0, 1],    # Direction vector (will be normalized)\n    \"xradius\": 10.0,           # Radius in x-direction\n    \"yradius\": 15.0,           # Radius in y-direction\n    \"zradius\": 20.0            # Radius in z-direction\n}\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#moleculeparameters","title":"MoleculeParameters","text":"<p>Defines parameters for molecular motion and behavior simulation.</p> <pre><code>class MoleculeParameters(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields_1","title":"Fields","text":"<ul> <li><code>num_molecules: List[int]</code></li> <li> <p>Description: Number of molecules for each type</p> </li> <li> <p><code>track_type: List[Literal[\"fbm\", \"constant\"]]</code></p> </li> <li>Description: Type of molecular motion</li> <li> <p>Valid values: \"fbm\" (fractional Brownian motion) or \"constant\"</p> </li> <li> <p><code>diffusion_coefficient: List[List[float]]</code></p> </li> <li>Description: Diffusion coefficients in \u03bcm\u00b2/s</li> <li> <p>2D array automatically converted to numpy array</p> </li> <li> <p><code>hurst_exponent: List[List[float]]</code></p> </li> <li>Description: Hurst exponents for fractional Brownian motion</li> <li> <p>2D array automatically converted to numpy array</p> </li> <li> <p><code>allow_transition_probability: List[bool]</code></p> </li> <li> <p>Description: Whether to allow state transitions</p> </li> <li> <p><code>transition_matrix_time_step: List[int]</code></p> </li> <li> <p>Description: Time step in milliseconds for transition matrices</p> </li> <li> <p><code>diffusion_transition_matrix: List[List[List[float]]]</code></p> </li> <li>Description: State transition probabilities for diffusion</li> <li> <p>3D array automatically converted to numpy array</p> </li> <li> <p><code>hurst_transition_matrix: List[List[List[float]]]</code></p> </li> <li>Description: State transition probabilities for Hurst exponent</li> <li> <p>3D array automatically converted to numpy array</p> </li> <li> <p><code>state_probability_diffusion: List[List[float]]</code></p> </li> <li>Description: Initial state probabilities for diffusion</li> <li> <p>2D array automatically converted to numpy array</p> </li> <li> <p><code>state_probability_hurst: List[List[float]]</code></p> </li> <li>Description: Initial state probabilities for Hurst exponent</li> <li>2D array automatically converted to numpy array</li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/#globalparameters","title":"GlobalParameters","text":"<p>Defines global simulation parameters.</p> <pre><code>class GlobalParameters(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields_2","title":"Fields","text":"<ul> <li><code>sample_plane_dim: List[float]</code></li> <li>Description: Sample plane dimensions in micrometers</li> <li> <p>Automatically converted to numpy array</p> </li> <li> <p><code>cycle_count: int</code></p> </li> <li> <p>Description: Number of simulation cycles</p> </li> <li> <p><code>exposure_time: int</code></p> </li> <li> <p>Description: Exposure time in milliseconds</p> </li> <li> <p><code>interval_time: int</code></p> </li> <li> <p>Description: Interval time in milliseconds</p> </li> <li> <p><code>oversample_motion_time: int</code></p> </li> <li>Description: Oversample motion time in milliseconds</li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/#condensateparameters","title":"CondensateParameters","text":"<p>Defines parameters for molecular condensate simulation.</p> <pre><code>class CondensateParameters(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields_3","title":"Fields","text":"<p>First dimension represents the types of molecules. (similar to the MoleculeParameters) - <code>initial_centers: List[List[List[float]]]</code>   - Description: Initial centers in micrometers   - 2D array automatically converted to numpy array</p> <ul> <li><code>initial_scale: List[List[float]]</code></li> <li>Description: Initial scale in micrometers</li> <li> <p>Automatically converted to numpy array</p> </li> <li> <p><code>diffusion_coefficient: List[List[float]]</code></p> </li> <li>Description: Diffusion coefficients in \u03bcm\u00b2/s</li> <li> <p>Automatically converted to numpy array</p> </li> <li> <p><code>hurst_exponent: List[List[float]]</code></p> </li> <li>Description: Hurst exponents for motion</li> <li> <p>Automatically converted to numpy array</p> </li> <li> <p><code>density_dif: List[int]</code></p> </li> <li>Description: Density difference parameter</li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/#outputparameters","title":"OutputParameters","text":"<p>Defines parameters for simulation output.</p> <pre><code>class OutputParameters(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields_4","title":"Fields","text":"<ul> <li><code>output_path: str</code></li> <li> <p>Description: Path for output files</p> </li> <li> <p><code>output_name: str</code></p> </li> <li> <p>Description: Base name for output files</p> </li> <li> <p><code>subsegment_type: str</code></p> </li> <li> <p>Description: Type of subsegmentation</p> </li> <li> <p><code>subsegment_number: int</code></p> </li> <li>Description: Number of subsegments</li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/#configlist","title":"ConfigList","text":"<p>Container model that combines all parameter models.</p> <pre><code>class ConfigList(BaseModel)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#fields_5","title":"Fields","text":"<ul> <li><code>CellParameters: CellParameters</code></li> <li><code>MoleculeParameters: MoleculeParameters</code></li> <li><code>GlobalParameters: GlobalParameters</code></li> <li><code>CondensateParameters: CondensateParameters</code></li> <li><code>OutputParameters: OutputParameters</code></li> </ul>"},{"location":"API_Documentation/core/configio/configmodels/#validation-features","title":"Validation Features","text":"<p>All models include automatic validation and conversion: - Numeric arrays are automatically converted to numpy arrays - Field types are strictly enforced - Required fields must be present - Literal fields must match specified values</p>"},{"location":"API_Documentation/core/configio/configmodels/#usage-example","title":"Usage Example","text":"<pre><code># Create configuration instance\nconfig = ConfigList(\n    CellParameter=CellParameters(\n        cell_space=[[0, 10], [0, 10]],\n        cell_axial_radius=5.0\n    ),\n    MoleculeParameter=MoleculeParameters(\n        num_molecules=[100],\n        track_type=[\"fbm\"],\n        # ... other required fields ...\n    ),\n    GlobalParameter=GlobalParameters(\n        sample_plane_dim=[20.0, 20.0],\n        cycle_count=100,\n        exposure_time=100,\n        interval_time=100,\n        oversample_motion_time=10\n    ),\n    CondensateParameter=CondensateParameters(\n        initial_centers=[[[5.0, 5.0]]],\n        initial_scale=[[2.0]],\n        diffusion_coefficient=[[0.1]],\n        hurst_exponent=[[0.7]],\n        density_dif=[2]\n    ),\n    OutputParameter=OutputParameters(\n        output_path=\"./output\",\n        output_name=\"simulation\",\n        subsegment_type=\"uniform\",\n        subsegment_number=10\n    )\n)\n</code></pre>"},{"location":"API_Documentation/core/configio/configmodels/#dependencies","title":"Dependencies","text":"<ul> <li><code>pydantic</code>: For data validation and settings management</li> <li><code>numpy</code>: For array operations</li> <li><code>typing</code>: For type hints</li> </ul>"},{"location":"API_Documentation/core/configio/convertconfig/","title":"Convertconfig","text":""},{"location":"API_Documentation/core/configio/convertconfig/#virtual-microscope-configuration-parser-documentation","title":"Virtual Microscope Configuration Parser Documentation","text":""},{"location":"API_Documentation/core/configio/convertconfig/#overview","title":"Overview","text":"<p>This module provides functionality to parse TOML configuration files and set up a virtual microscope simulation environment. It handles all aspects of configuration including global parameters, cell parameters, molecule parameters, condensate parameters, fluorophores, PSF (Point Spread Function), lasers, filters, channels, detectors, and experimental settings.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#key-components","title":"Key Components","text":""},{"location":"API_Documentation/core/configio/convertconfig/#configuration-loading","title":"Configuration Loading","text":"<pre><code>load_config(config_path: Union[str, Path]) -&gt; Dict[str, Any]\n</code></pre> <p>Loads and parses a TOML configuration file from the specified path.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#data-model-schema-population","title":"Data Model Schema Population","text":"<pre><code>populate_dataclass_schema(config: Dict[str, Any]) -&gt; Tuple[GlobalParameters, CellParameters, MoleculeParameters, CondensateParameters, OutputParameters]\n</code></pre> <p>Populates Pydantic schema models from configuration data, returning structured parameter objects.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#experiment-configuration","title":"Experiment Configuration","text":"<pre><code>create_experiment_from_config(config: Dict[str, Any]) -&gt; Tuple[BaseExpConfig, Callable]\n</code></pre> <p>Creates an experiment configuration and associated callable function based on the experiment type (time-series or z-stack).</p>"},{"location":"API_Documentation/core/configio/convertconfig/#fluorophore-configuration","title":"Fluorophore Configuration","text":"<pre><code>create_fluorophores_from_config(config: Dict[str, Any]) -&gt; List[Fluorophore]\n</code></pre> <p>Creates a list of fluorophore objects from configuration data, including states and transitions.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#psf-point-spread-function-configuration","title":"PSF (Point Spread Function) Configuration","text":"<pre><code>create_psf_from_config(config: Dict[str, Any]) -&gt; Tuple[Callable, Dict[str, Any]]\n</code></pre> <p>Creates a PSF engine function and additional configuration from the config data.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#laser-configuration","title":"Laser Configuration","text":"<pre><code>create_lasers_from_config(config: Dict[str, Any]) -&gt; Dict[str, LaserProfile]\n</code></pre> <p>Creates laser profile instances (Gaussian, Widefield, HiLo) from configuration data.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#filter-configuration","title":"Filter Configuration","text":"<pre><code>create_filter_set_from_config(config: Dict[str, Any]) -&gt; FilterSet\n</code></pre> <p>Creates a filter set (excitation, emission, dichroic) from configuration data.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#channel-configuration","title":"Channel Configuration","text":"<pre><code>create_channels(config: Dict[str, Any]) -&gt; Channels\n</code></pre> <p>Creates channel objects from configuration data.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#detector-configuration","title":"Detector Configuration","text":"<pre><code>create_detector_from_config(config: Dict[str, Any]) -&gt; Tuple[Detector, QuantumEfficiency]\n</code></pre> <p>Creates a detector instance (CMOS or EMCCD) and quantum efficiency from configuration data.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#cell-creation","title":"Cell Creation","text":"<pre><code>create_cell_from_params(cell_params) -&gt; BaseCell\n</code></pre> <p>Creates a cell object based on cell parameters.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#sample-plane-creation","title":"Sample Plane Creation","text":"<pre><code>create_sample_plane(global_params: GlobalParameters, cell: BaseCell) -&gt; SamplePlane\n</code></pre> <p>Creates a sample plane object based on global parameters and cell information.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#condensate-configuration","title":"Condensate Configuration","text":"<pre><code>create_condensates_dict(condensate_params: CondensateParameters, cell: BaseCell) -&gt; List[dict]\n</code></pre> <p>Creates a list of condensate dictionaries based on condensate parameters.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#sampling-function-creation","title":"Sampling Function Creation","text":"<pre><code>create_sampling_functions(condensate_params, cell) -&gt; List[Callable]\n</code></pre> <p>Creates sampling functions for initial molecule positions.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#molecule-position-generation","title":"Molecule Position Generation","text":"<pre><code>generate_initial_positions(molecule_params: MoleculeParameters, cell: BaseCell, condensate_params: CondensateParameters, sampling_functions: List[Callable]) -&gt; List\n</code></pre> <p>Generates initial positions for molecules.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#track-generation","title":"Track Generation","text":"<pre><code>create_track_generator(global_params: GlobalParameters, cell: BaseCell) -&gt; Track_generator\n</code></pre> <p>Creates a track generator object for molecule motion.</p> <pre><code>get_tracks(molecule_params: MoleculeParameters, global_params: GlobalParameters, initial_positions: List, track_generator: Track_generator) -&gt; Tuple[List, List]\n</code></pre> <p>Generates tracks for molecules based on parameters.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#sample-creation","title":"Sample Creation","text":"<pre><code>add_tracks_to_sample(tracks: List, sample_plane: SamplePlane, fluorophore: List[Fluorophore], ID_counter=0) -&gt; SamplePlane\n</code></pre> <p>Adds tracks to the sample plane.</p>"},{"location":"API_Documentation/core/configio/convertconfig/#microscope-setup","title":"Microscope Setup","text":"<pre><code>setup_microscope(config: Dict[str, Any]) -&gt; dict\n</code></pre> <p>The main function that orchestrates the entire setup process and returns a dictionary containing all created components including: - Virtual microscope instance - Base configuration - PSF engine and configuration - Channels - Lasers - Sample plane - Tracks - Points per time - Condensate dictionary - Cell - Experiment configuration - Experiment function</p>"},{"location":"API_Documentation/core/configio/convertconfig/#usage","title":"Usage","text":"<p>To use this module, create a TOML configuration file with all necessary parameters and call the <code>setup_microscope</code> function:</p> <pre><code>config = load_config(\"path/to/config.toml\")\nmicroscope_setup = setup_microscope(config)\n\n# Access the virtual microscope instance\nvm = microscope_setup[\"microscope\"]\n\n# Run an experiment\nexperiment_func = microscope_setup[\"experiment_func\"]\nexperiment_config = microscope_setup[\"experiment_config\"]\nresults = experiment_func(vm, experiment_config)\n</code></pre>"},{"location":"API_Documentation/core/configio/convertconfig/#configuration-structure","title":"Configuration Structure","text":"<p>The TOML configuration file should contain the following sections: - Global_Parameters: General simulation parameters - Cell_Parameters: Cell-specific parameters - Molecule_Parameters: Molecule-specific parameters - Condensate_Parameters: Condensate-specific parameters - Output_Parameters: Output and saving parameters - experiment: Experiment-specific parameters - fluorophores: Fluorophore definitions - psf: PSF configuration - lasers: Laser configurations - channels: Channel configurations - camera: Camera and detector configurations</p>"},{"location":"API_Documentation/core/configio/experiments/","title":"Experiments","text":""},{"location":"API_Documentation/core/configio/experiments/#module-experimentspy","title":"Module: <code>experiments.py</code>","text":"<p>This module provides functionality for defining and running experiments in a simulated microscopy environment. It includes dataclasses for configuring experiments and functions to execute these experiments using a virtual microscope.</p>"},{"location":"API_Documentation/core/configio/experiments/#imports","title":"Imports","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional, Tuple\n\nimport numpy as np\n\nfrom ..metadata.metadata import MetaData\nfrom ..sim_microscopy import VirtualMicroscope\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#dataclasses","title":"Dataclasses","text":""},{"location":"API_Documentation/core/configio/experiments/#baseexpconfig","title":"<code>BaseExpConfig</code>","text":"<p>Base configuration class for experiments.</p> <p>Attributes: - <code>name</code> (<code>str</code>): Name of the experiment. - <code>description</code> (<code>str</code>): Description of the experiment.</p> <pre><code>@dataclass\nclass BaseExpConfig:\n    name: str\n    description: str\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#timeseriesexpconfig","title":"<code>TimeSeriesExpConfig</code>","text":"<p>Configuration class for time series experiments.</p> <p>Attributes: - <code>z_position</code> (<code>float</code>): Z-position for the experiment. - <code>laser_names_active</code> (<code>List[str]</code>): List of active laser names. - <code>laser_powers_active</code> (<code>List[float]</code>): List of active laser powers. - <code>laser_positions_active</code> (<code>List</code>): List of active laser positions. - <code>xyoffset</code> (<code>Tuple[float, float]</code>): XY offset for the experiment. - <code>exposure_time</code> (<code>Optional[int]</code>): Exposure time (optional). - <code>interval_time</code> (<code>Optional[int]</code>): Interval time (optional). - <code>duration_time</code> (<code>Optional[int]</code>): Duration time (optional).</p> <p>Methods: - <code>__post_init__()</code>: Validates the configuration and sets up laser powers and positions.</p> <pre><code>@dataclass\nclass TimeSeriesExpConfig(BaseExpConfig):\n    z_position: float\n    laser_names_active: List[str]\n    laser_powers_active: List[float]\n    laser_positions_active: List\n    xyoffset: Tuple[float, float]\n\n    exposure_time: Optional[int] = None\n    interval_time: Optional[int] = None\n    duration_time: Optional[int] = None\n\n    def __post_init__(self):\n        len_ln = len(self.laser_names_active)\n        len_lpow = len(self.laser_powers_active)\n        len_lpos = len(self.laser_positions_active)\n        if len_ln != len_lpos or len_ln != len_lpow:\n            raise ValueError(\n                f\"Length mismatch among lists: \"\n                f\"laser_names_active({len_ln}), \"\n                f\"laser_powers_active({len_lpow}), \"\n                f\"laser_positions_active({len_lpos})\"\n            )\n        if self.exposure_time or self.interval_time or self.duration_time:\n            raise ValueError(\n                \"Please do not define exposure_time, interval_time, or duration_time in a time series experiment component. Use the GlobalParameters to set this.\"\n            )\n        self.laser_powers = {\n            self.laser_names_active[i]: self.laser_powers_active[i]\n            for i in range(len(self.laser_names_active))\n        }\n        self.laser_positions = {\n            self.laser_names_active[i]: self.laser_positions_active[i]\n            for i in range(len(self.laser_names_active))\n        }\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#zstackexpconfig","title":"<code>zStackExpConfig</code>","text":"<p>Configuration class for z-stack experiments.</p> <p>Attributes: - <code>z_position</code> (<code>List[float]</code>): List of Z-positions for the experiment. - <code>laser_names_active</code> (<code>List[str]</code>): List of active laser names. - <code>laser_powers_active</code> (<code>List[float]</code>): List of active laser powers. - <code>laser_positions_active</code> (<code>List</code>): List of active laser positions. - <code>xyoffset</code> (<code>Tuple[float, float]</code>): XY offset for the experiment. - <code>exposure_time</code> (<code>int</code>): Exposure time. - <code>interval_time</code> (<code>int</code>): Interval time.</p> <p>Methods: - <code>__post_init__()</code>: Validates the configuration and sets up laser powers and positions.</p> <pre><code>@dataclass\nclass zStackExpConfig(BaseExpConfig):\n    z_position: List[float]\n    laser_names_active: List[str]\n    laser_powers_active: List[float]\n    laser_positions_active: List\n    xyoffset: Tuple[float, float]\n\n    exposure_time: int\n    interval_time: int\n\n    def __post_init__(self):\n        len_ln = len(self.laser_names_active)\n        len_lpow = len(self.laser_powers_active)\n        len_lpos = len(self.laser_positions_active)\n        if len_ln != len_lpos or len_ln != len_lpow:\n            raise ValueError(\n                f\"Length mismatch among lists: \"\n                f\"laser_names_active({len_ln}), \"\n                f\"laser_powers_active({len_lpow}), \"\n                f\"laser_positions_active({len_lpos})\"\n            )\n        self.laser_powers = {\n            self.laser_names_active[i]: self.laser_powers_active[i]\n            for i in range(len(self.laser_names_active))\n        }\n        self.laser_positions = {\n            self.laser_names_active[i]: self.laser_positions_active[i]\n            for i in range(len(self.laser_names_active))\n        }\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/configio/experiments/#timeseriesexp","title":"<code>timeseriesEXP</code>","text":"<p>Runs a time series experiment using the provided virtual microscope and configuration.</p> <p>Parameters: - <code>microscope</code> (<code>VirtualMicroscope</code>): The virtual microscope instance. - <code>config</code> (<code>TimeSeriesExpConfig</code>): Configuration for the time series experiment.</p> <p>Returns: - <code>Tuple[np.ndarray, MetaData]</code>: A tuple containing the frames and metadata.</p> <pre><code>def timeseriesEXP(\n    microscope: VirtualMicroscope,\n    config: TimeSeriesExpConfig,\n) -&gt; Tuple[np.ndarray, MetaData]:\n    frames, metadata = microscope.run_sim(\n        z_val=config.z_position,\n        laser_power=config.laser_powers,\n        laser_position=config.laser_positions,\n        xyoffset=config.xyoffset,\n        duration_total=config.duration_time,\n        exposure_time=config.exposure_time,\n        interval_time=config.interval_time,\n    )\n    return np.array([frames]), metadata\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#zseriesexp","title":"<code>zseriesEXP</code>","text":"<p>Runs a z-series (z-stack) experiment using the provided virtual microscope and configuration.</p> <p>Parameters: - <code>microscope</code> (<code>VirtualMicroscope</code>): The virtual microscope instance. - <code>config</code> (<code>zStackExpConfig</code>): Configuration for the z-stack experiment.</p> <p>Returns: - <code>Tuple[np.ndarray, MetaData]</code>: A tuple containing the frames and metadata.</p> <pre><code>def zseriesEXP(\n    microscope: VirtualMicroscope,\n    config: zStackExpConfig,\n) -&gt; Tuple[np.ndarray, MetaData]:\n    frames = []\n    for i in config.z_position:\n        f, m = microscope.run_sim(\n            z_val=i,\n            laser_power=config.laser_powers,\n            laser_position=config.laser_positions,\n            xyoffset=config.xyoffset,\n            duration_total=config.exposure_time + config.interval_time,\n            exposure_time=config.exposure_time,\n            interval_time=config.interval_time,\n        )\n        frames.append(f)\n    metadata = m\n    return np.array(frames), metadata\n</code></pre>"},{"location":"API_Documentation/core/configio/experiments/#summary","title":"Summary","text":"<p>This module provides a structured way to define and run experiments in a simulated microscopy environment. The <code>TimeSeriesExpConfig</code> and <code>zStackExpConfig</code> classes allow for detailed configuration of experiments, while the <code>timeseriesEXP</code> and <code>zseriesEXP</code> functions enable the execution of these experiments using a virtual microscope.</p>"},{"location":"API_Documentation/core/configio/saving/","title":"Saving","text":""},{"location":"API_Documentation/core/configio/saving/#module-savingpy","title":"Module: <code>saving.py</code>","text":"<p>The <code>saving.py</code> module provides functionality for saving processed data and metadata to disk. It includes methods to save image frames as TIFF files and metadata as JSON files.</p>"},{"location":"API_Documentation/core/configio/saving/#dependencies","title":"Dependencies","text":"<ul> <li><code>json</code>: For handling JSON serialization and deserialization.</li> <li><code>os</code>: For interacting with the operating system, such as file and directory operations.</li> <li><code>numpy</code>: For handling numerical data, particularly image frames.</li> <li><code>tifffile.TiffWriter</code>: For writing image data to TIFF files.</li> <li><code>OutputParameters</code>: A model from the <code>configio.configmodels</code> module, representing output parameters.</li> <li><code>MetaData</code>: A model from the <code>metadata.metadata</code> module, representing metadata associated with the data.</li> </ul>"},{"location":"API_Documentation/core/configio/saving/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/configio/saving/#save_config_frames","title":"<code>save_config_frames</code>","text":"<pre><code>def save_config_frames(\n    config: MetaData, frames: np.ndarray, outputparams: OutputParameters\n) -&gt; None:\n</code></pre> <p>Saves the provided image frames and associated metadata to disk.</p>"},{"location":"API_Documentation/core/configio/saving/#parameters","title":"Parameters","text":"<ul> <li>config (<code>MetaData</code>): </li> <li> <p>Metadata associated with the image frames. This includes information such as axes definitions and other relevant metadata.</p> </li> <li> <p>frames (<code>np.ndarray</code>): </p> </li> <li> <p>A NumPy array containing the image frames to be saved.</p> </li> <li> <p>outputparams (<code>OutputParameters</code>): </p> </li> <li>An instance of <code>OutputParameters</code> containing the output path and file name.</li> </ul>"},{"location":"API_Documentation/core/configio/saving/#returns","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"API_Documentation/core/configio/saving/#behavior","title":"Behavior","text":"<ol> <li>Directory Creation: </li> <li> <p>If the directory specified in <code>outputparams.output_path</code> does not exist, it will be created.</p> </li> <li> <p>TIFF File Writing: </p> </li> <li>The image frames are saved as a TIFF file using the <code>TiffWriter</code> class from the <code>tifffile</code> library. The file is saved with the name specified in <code>outputparams.output_name</code> and the <code>.ome.tiff</code> extension. The <code>bigtiff=True</code> parameter ensures that the file can handle large datasets.</li> <li> <p>The metadata from the <code>config</code> object, excluding any notes, is embedded in the TIFF file.</p> </li> <li> <p>JSON Metadata Saving: </p> </li> <li>The complete metadata from the <code>config</code> object is serialized to a JSON file named <code>metadata.json</code> in the same directory as the TIFF file.</li> </ol>"},{"location":"API_Documentation/core/configio/saving/#example","title":"Example","text":"<pre><code>from ..configio.configmodels import OutputParameters\nfrom ..metadata.metadata import MetaData\nimport numpy as np\n\n# Example usage\nconfig = MetaData(axes=\"TYX\", notes=\"Example metadata\")\nframes = np.random.rand(10, 256, 256)  # Example frames\noutputparams = OutputParameters(output_path=\"./output\", output_name=\"example\")\n\nsave_config_frames(config, frames, outputparams)\n</code></pre> <p>This will save the frames as <code>example.ome.tiff</code> in the <code>./output</code> directory and the metadata as <code>metadata.json</code> in the same directory.</p>"},{"location":"API_Documentation/core/configio/saving/#notes","title":"Notes","text":"<ul> <li>The function assumes that the <code>MetaData</code> and <code>OutputParameters</code> models have appropriate methods (<code>model_dump</code>) for serializing their data.</li> <li>The <code>TiffWriter</code> class is used for writing TIFF files, and it is assumed that the <code>tifffile</code> library is installed and properly configured.</li> <li>The function handles large datasets by using the <code>bigtiff=True</code> parameter, which is necessary for datasets that exceed the 4GB limit of standard TIFF files.</li> </ul>"},{"location":"API_Documentation/core/groundtruth_generators/nuclearporecomplexes/","title":"Nuclearporecomplexes","text":""},{"location":"API_Documentation/core/groundtruth_generators/nuclearporecomplexes/#AMS_BP.core.groundtruth_generators.nuclearporecomplexes.generate_nup96_positions","title":"<code>generate_nup96_positions(ring_diameter=107.0, molecule_spacing=12.0, ring_spacing=50.0)</code>","text":"<p>Generate the 3D coordinates of Nup96 proteins in the nuclear pore complex.</p>"},{"location":"API_Documentation/core/groundtruth_generators/nuclearporecomplexes/#AMS_BP.core.groundtruth_generators.nuclearporecomplexes.generate_nup96_positions--parameters","title":"Parameters:","text":"<p>ring_diameter : float     Diameter of the main ring in nanometers (default: 107.0 nm) molecule_spacing : float     Distance between two Nup96 molecules within same section (default: 12.0 nm) ring_spacing : float     Distance between nuclear and cytoplasmic rings in z-direction (default: 50.0 nm)</p>"},{"location":"API_Documentation/core/groundtruth_generators/nuclearporecomplexes/#AMS_BP.core.groundtruth_generators.nuclearporecomplexes.generate_nup96_positions--returns","title":"Returns:","text":"<p>numpy.ndarray     Array of shape (32, 3) containing x, y, z coordinates for all Nup96 proteins in um     First 32 coordinates are the main structural Nup96 (16 nuclear, 16 cytoplasmic)</p>"},{"location":"API_Documentation/core/metadata/metadata/","title":"Metadata","text":""},{"location":"API_Documentation/core/metadata/metadata/#module-metadatapy","title":"Module: <code>metadata.py</code>","text":"<p>This module defines a <code>StringNode</code> class for representing hierarchical string structures and a <code>MetaData</code> class for storing metadata information. The <code>StringNode</code> class allows for the creation of tree-like structures where each node can either contain a string value or a list of child nodes. The <code>MetaData</code> class uses <code>pydantic</code> for data validation and includes fields for various metadata attributes.</p>"},{"location":"API_Documentation/core/metadata/metadata/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/metadata/metadata/#stringnode","title":"<code>StringNode</code>","text":"<p>A class representing a node in a hierarchical structure of strings. Each node can either contain a string value or a list of child nodes.</p>"},{"location":"API_Documentation/core/metadata/metadata/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, value: Union[str, List[\"StringNode\"]] = None) -&gt; None</code></li> </ul> <p>Initializes a node with either a string or a nested list of nodes.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>value</code> (<code>Union[str, List[\"StringNode\"]]</code>): The value to initialize the node with. Can be a string, a list of <code>StringNode</code> objects, or <code>None</code>.</li> </ul> </li> <li> <p>Raises:</p> <ul> <li><code>ValueError</code>: If the value is not a string, a list of <code>StringNode</code>, or <code>None</code>.</li> </ul> </li> <li> <p><code>is_leaf(self) -&gt; bool</code></p> </li> </ul> <p>Checks if this node is a leaf node (contains a string).</p> <ul> <li> <p>Returns:</p> <ul> <li><code>bool</code>: <code>True</code> if the node is a leaf node, <code>False</code> otherwise.</li> </ul> </li> <li> <p><code>add(self, child: \"StringNode\") -&gt; None</code></p> </li> </ul> <p>Adds a child node to this node.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>child</code> (<code>StringNode</code>): The child node to add.</li> </ul> </li> <li> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the node is a leaf node (cannot add children to a leaf node).</li> </ul> </li> <li> <p><code>remove(self, child: \"StringNode\") -&gt; None</code></p> </li> </ul> <p>Removes a child node.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>child</code> (<code>StringNode</code>): The child node to remove.</li> </ul> </li> <li> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the node is a leaf node (cannot remove children from a leaf node).</li> </ul> </li> <li> <p><code>__repr__(self) -&gt; str</code></p> </li> </ul> <p>Returns a string representation of the node.</p> <ul> <li> <p>Returns:</p> <ul> <li><code>str</code>: A string representation of the node.</li> </ul> </li> <li> <p><code>__iter__(self) -&gt; Iterator[\"StringNode\"]</code></p> </li> </ul> <p>Iterates over children if this is not a leaf node.</p> <ul> <li> <p>Returns:</p> <ul> <li><code>Iterator[StringNode]</code>: An iterator over the children nodes.</li> </ul> </li> <li> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the node is a leaf node (leaf nodes are not iterable).</li> </ul> </li> </ul>"},{"location":"API_Documentation/core/metadata/metadata/#metadata","title":"<code>MetaData</code>","text":"<p>A class for storing metadata information, using <code>pydantic</code> for data validation.</p>"},{"location":"API_Documentation/core/metadata/metadata/#attributes","title":"Attributes","text":"<ul> <li><code>notes</code> (<code>StringNode | list | str</code>): Notes associated with the metadata. Can be a <code>StringNode</code>, a list, or a string.</li> <li><code>axes</code> (<code>str</code>): The axes of the metadata.</li> <li><code>TimeIncrement</code> (<code>float</code>): The time increment value.</li> <li><code>TimeIncrementUnit</code> (<code>Literal[\"s\", \"ms\"]</code>): The unit of the time increment. Can be either \"s\" (seconds) or \"ms\" (milliseconds).</li> <li><code>PhysicalSizeX</code> (<code>float</code>): The physical size in the X dimension.</li> <li><code>PhysicalSizeXUnit</code> (<code>Literal[\"nm\", \"m\"]</code>): The unit of the physical size in the X dimension. Can be either \"nm\" (nanometers) or \"m\" (meters).</li> <li><code>PhysicalSizeY</code> (<code>float</code>): The physical size in the Y dimension.</li> <li><code>PhysicalSizeYUnit</code> (<code>Literal[\"nm\", \"m\"]</code>): The unit of the physical size in the Y dimension. Can be either \"nm\" (nanometers) or \"m\" (meters).</li> </ul>"},{"location":"API_Documentation/core/metadata/metadata/#methods_1","title":"Methods","text":"<ul> <li><code>__post_init__(self)</code></li> </ul> <p>Post-initialization method to convert the <code>notes</code> attribute to a <code>StringNode</code> if it is a list or a string.</p>"},{"location":"API_Documentation/core/metadata/metadata/#class-configuration","title":"Class Configuration","text":"<ul> <li><code>Config</code>:</li> <li><code>arbitrary_types_allowed</code> (<code>bool</code>): Allows arbitrary types to be used in the model.</li> </ul>"},{"location":"API_Documentation/core/metadata/metadata/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/metadata/metadata/#to_string_nodenested-unionstr-list-stringnode","title":"<code>to_string_node(nested: Union[str, List]) -&gt; StringNode</code>","text":"<p>Converts a nested list of strings into a <code>StringNode</code> structure.</p> <ul> <li>Parameters:</li> <li> <p><code>nested</code> (<code>Union[str, List]</code>): A string or a nested list of strings.</p> </li> <li> <p>Returns:</p> </li> <li> <p><code>StringNode</code>: A <code>StringNode</code> representing the nested structure.</p> </li> <li> <p>Raises:</p> </li> <li><code>ValueError</code>: If the input is not a string or a nested list of strings.</li> </ul> <p>This documentation provides an overview of the <code>metadata.py</code> module, detailing the classes, methods, and functions it contains. The <code>StringNode</code> class is particularly useful for creating hierarchical string structures, while the <code>MetaData</code> class is designed for storing and validating metadata information.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/","title":"Condensate movement","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#module-condensate_movementpy","title":"Module: condensate_movement.py","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#overview","title":"Overview","text":"<p>The <code>condensate_movement</code> module contains classes and functions for simulating and managing the movement and properties of condensates. Condensates are defined as spherical entities characterized by their center coordinates (x, y, z), radius (r), and time (t). This module provides functionalities to create, manipulate, and analyze condensates within a simulation environment.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#condensate","title":"<code>Condensate</code>","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#description","title":"Description","text":"<p>The <code>Condensate</code> class is used to store and manage data related to condensates. Each condensate is defined by its initial position, time, diffusion coefficient, Hurst exponent, and other relevant parameters.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/#parameters","title":"Parameters","text":"<ul> <li> <p>initial_position: <code>np.ndarray</code>   The initial position of the condensate. Default is <code>np.array([0, 0, 0])</code>.</p> </li> <li> <p>initial_time: <code>float</code>   The initial time of the condensate. Default is <code>0</code>.</p> </li> <li> <p>diffusion_coefficient: <code>float</code>   The diffusion coefficient of the condensate. Default is <code>0</code>.</p> </li> <li> <p>hurst_exponent: <code>float</code>   The Hurst exponent of the condensate. Default is <code>0</code>.</p> </li> <li> <p>units_time: <code>str</code>   The units of time. Default is <code>'s'</code>. The time units work as follows:</p> </li> <li>For <code>'ms'</code>, 1 unit represents 1 millisecond.</li> <li>For <code>'s'</code>, 1 unit represents 1 second.</li> <li> <p>For <code>'20ms'</code>, 1 unit represents 20 milliseconds.</p> </li> <li> <p>units_position: <code>str</code>   The units of position. Default is <code>'um'</code>.</p> </li> <li> <p>condensate_id: <code>int</code>   The ID of the condensate. Default is <code>0</code>.</p> </li> <li> <p>initial_scale: <code>float</code>   The initial scale of the condensate. Default is <code>0</code>.</p> </li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#usage","title":"Usage","text":"<pre><code>condensate = Condensate(**{\n    \"initial_position\": np.array([0, 0, 0]),\n    \"initial_time\": 0,\n    \"diffusion_coefficient\": 0,\n    \"hurst_exponent\": 0,\n    \"units_time\": 'ms',\n    \"units_position\": 'um',\n    \"condensate_id\": 0,\n    \"initial_scale\": 0,\n})\n</code></pre>"},{"location":"API_Documentation/core/motion/condensate_movement/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#create_condensate_dict","title":"<code>create_condensate_dict</code>","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#description_1","title":"Description","text":"<p>Creates a dictionary of condensates for simulation. Each condensate is initialized with specific parameters such as initial centers, scales, diffusion coefficients, and Hurst exponents.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/#parameters_1","title":"Parameters","text":"<ul> <li> <p>initial_centers: <code>np.ndarray</code>   An array of shape <code>(num_condensates, 2)</code> representing the initial centers of the condensates.</p> </li> <li> <p>initial_scale: <code>np.ndarray</code>   An array of shape <code>(num_condensates, 2)</code> representing the initial scales of the condensates.</p> </li> <li> <p>diffusion_coefficient: <code>np.ndarray</code>   An array of shape <code>(num_condensates, 2)</code> representing the diffusion coefficients of the condensates.</p> </li> <li> <p>hurst_exponent: <code>np.ndarray</code>   An array of shape <code>(num_condensates, 2)</code> representing the Hurst exponents of the condensates.</p> </li> <li> <p>cell: <code>RectangularCell</code>   The rectangular cell that contains the condensates.</p> </li> <li> <p>kwargs: <code>dict</code>   Additional arguments passed to the <code>Condensate</code> class.</p> </li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#returns","title":"Returns","text":"<ul> <li>dict: A dictionary of <code>Condensate</code> objects with keys as condensate IDs.</li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#usage_1","title":"Usage","text":"<pre><code>condensates = create_condensate_dict(\n    initial_centers=np.array([[0, 0], [1, 1]]),\n    initial_scale=np.array([1, 2]),\n    diffusion_coefficient=np.array([0.1, 0.2]),\n    hurst_exponent=np.array([0.5, 0.6]),\n    cell=RectangularCell(),\n)\n</code></pre>"},{"location":"API_Documentation/core/motion/condensate_movement/#_generate_transition_tracks","title":"<code>_generate_transition_tracks</code>","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#description_2","title":"Description","text":"<p>Generates tracks with state transitions for condensates. This function is used to simulate the movement of condensates under varying conditions defined by transition matrices and state probabilities.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/#parameters_2","title":"Parameters","text":"<ul> <li> <p>track_generator: <code>Track_generator</code>   An instance of the track generator.</p> </li> <li> <p>track_lengths: <code>list | np.ndarray | int</code>   The lengths of the tracks to be generated.</p> </li> <li> <p>initial_positions: <code>np.ndarray</code>   The initial positions of the condensates.</p> </li> <li> <p>starting_frames: <code>int</code>   The starting frames for the tracks.</p> </li> <li> <p>diffusion_parameters: <code>np.ndarray</code>   The diffusion parameters for the condensates.</p> </li> <li> <p>hurst_parameters: <code>np.ndarray</code>   The Hurst parameters for the condensates.</p> </li> <li> <p>diffusion_transition_matrix: <code>np.ndarray</code>   The transition matrix for diffusion states.</p> </li> <li> <p>hurst_transition_matrix: <code>np.ndarray</code>   The transition matrix for Hurst states.</p> </li> <li> <p>diffusion_state_probability: <code>np.ndarray</code>   The state probability for diffusion.</p> </li> <li> <p>hurst_state_probability: <code>np.ndarray</code>   The state probability for Hurst.</p> </li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#returns_1","title":"Returns","text":"<ul> <li>tuple[dict, dict]: A tuple containing the tracks dictionary and points per time dictionary.</li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#_convert_tracks_to_trajectory","title":"<code>_convert_tracks_to_trajectory</code>","text":""},{"location":"API_Documentation/core/motion/condensate_movement/#description_3","title":"Description","text":"<p>Converts the generated tracks into a trajectory format.</p>"},{"location":"API_Documentation/core/motion/condensate_movement/#parameters_3","title":"Parameters","text":"<ul> <li>tracks: <code>dict</code>   The dictionary of tracks to be converted.</li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#returns_2","title":"Returns","text":"<ul> <li>dict: The converted trajectory data.</li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#dependencies","title":"Dependencies","text":"<ul> <li><code>matplotlib.pyplot</code></li> <li><code>numpy</code></li> <li><code>RectangularCell</code> from <code>..cells.rectangular_cell</code></li> <li><code>cache</code> from <code>..utils.decorators</code></li> <li><code>Track_generator</code> from <code>track_gen</code></li> </ul>"},{"location":"API_Documentation/core/motion/condensate_movement/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nfrom ..cells.rectangular_cell import RectangularCell\nfrom .condensate_movement import create_condensate_dict, Condensate\n\n# Initialize a rectangular cell\ncell = RectangularCell()\n\n# Create condensates\ncondensates = create_condensate_dict(\n    initial_centers=np.array([[0, 0], [1, 1]]),\n    initial_scale=np.array([1, 2]),\n    diffusion_coefficient=np.array([0.1, 0.2]),\n    hurst_exponent=np.array([0.5, 0.6]),\n    cell=cell,\n)\n\n# Access a condensate\ncondensate = condensates['0']\n\n# Get position and scale at a given time\nresult = condensate(times=10, time_unit='ms')\nprint(result)\n</code></pre> <p>This documentation provides a comprehensive overview of the <code>condensate_movement</code> module, detailing its classes, functions, and dependencies. The provided example demonstrates how to initialize and use the <code>Condensate</code> class and related functions for simulating condensate movements.</p>"},{"location":"API_Documentation/core/motion/track_gen/","title":"Track gen","text":""},{"location":"API_Documentation/core/motion/track_gen/#track_genpy-documentation","title":"<code>track_gen.py</code> Documentation","text":""},{"location":"API_Documentation/core/motion/track_gen/#overview","title":"Overview","text":"<p>The <code>track_gen.py</code> module provides functionality to simulate foci dynamics in space, particularly within cell simulations. It includes a <code>Track_generator</code> class that generates tracks of foci movements in a simulated cell space, with options for transitions between different diffusion coefficients and Hurst exponents.</p>"},{"location":"API_Documentation/core/motion/track_gen/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/motion/track_gen/#track_generator","title":"<code>Track_generator</code>","text":"<p>A class to generate tracks of foci movements in a simulated cell space.</p>"},{"location":"API_Documentation/core/motion/track_gen/#parameters","title":"Parameters","text":"<ul> <li>cell (<code>CellType</code>): </li> <li>A cell object defining the space for track generation.</li> <li>cycle_count (<code>int</code>): </li> <li>The number of frames for the simulation.</li> <li>exposure_time (<code>int | float</code>): </li> <li>Exposure time in milliseconds.</li> <li>interval_time (<code>int | float</code>): </li> <li>Interval time between frames in milliseconds.</li> <li>oversample_motion_time (<code>int | float</code>): </li> <li>Time for oversampling motion in milliseconds.</li> </ul>"},{"location":"API_Documentation/core/motion/track_gen/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, cell: CellType, cycle_count: int, exposure_time: int | float, interval_time: int | float, oversample_motion_time: int | float) -&gt; None</code>:</li> <li> <p>Initializes the <code>Track_generator</code> object.</p> </li> <li> <p><code>_allowable_cell_types(self)</code>:</p> </li> <li> <p>Checks if the cell type is supported (currently only rectangular cells are supported).</p> </li> <li> <p><code>track_generation_no_transition(self, diffusion_coefficient: float, hurst_exponent: float, track_length: int, initials: np.ndarray, start_time: int | float) -&gt; dict</code>:</p> </li> <li> <p>Simulates track generation with no transition between diffusion coefficients and Hurst exponents.</p> </li> <li> <p><code>track_generation_with_transition(self, diffusion_transition_matrix: np.ndarray | list, hurst_transition_matrix: np.ndarray | list, diffusion_parameters: np.ndarray | list, hurst_parameters: np.ndarray | list, diffusion_state_probability: np.ndarray | list, hurst_state_probability: np.ndarray | list, track_length: int, initials: np.ndarray, start_time: int | float) -&gt; dict</code>:</p> </li> <li> <p>Generates track data with transitions between diffusion coefficients and Hurst exponents.</p> </li> <li> <p><code>track_generation_constant(self, track_length: int, initials: np.ndarray, start_time: int) -&gt; dict</code>:</p> </li> <li> <p>Generates a constant track (no movement).</p> </li> <li> <p><code>_convert_diffcoef_um2s_um2xms(self, diffusion_coefficient: float | np.ndarray | list) -&gt; float | np.ndarray | list</code>:</p> </li> <li> <p>Converts diffusion coefficient from <code>um^2/s</code> to <code>um^2/x ms</code>.</p> </li> <li> <p><code>_convert_time_to_frame(self, time: int) -&gt; int</code>:</p> </li> <li> <p>Converts time in milliseconds to frame number.</p> </li> <li> <p><code>_convert_frame_to_time(self, frame: int) -&gt; int</code>:</p> </li> <li>Converts frame number to time in milliseconds.</li> </ul>"},{"location":"API_Documentation/core/motion/track_gen/#private-methods","title":"Private Methods","text":"<ul> <li><code>_allowable_cell_types(self)</code>:</li> <li>Ensures that only rectangular cells are supported for track generation.</li> </ul>"},{"location":"API_Documentation/core/motion/track_gen/#functions","title":"Functions","text":"<ul> <li><code>_initialize_points_per_time(total_time: int, oversample_motion_time: int) -&gt; dict</code>:</li> <li> <p>Initializes an empty dictionary with keys for each time point.</p> </li> <li> <p><code>_update_points_per_time(points_per_time: dict, track: dict) -&gt; None</code>:</p> </li> <li> <p>Updates the points per time dictionary with new track data.</p> </li> <li> <p><code>_generate_constant_tracks(track_generator: Track_generator, track_lengths: list | np.ndarray | int, initial_positions: np.ndarray, starting_frames: int = 0) -&gt; tuple[dict, dict]</code>:</p> </li> <li> <p>Generates tracks with constant parameters.</p> </li> <li> <p><code>_generate_no_transition_tracks(track_generator: Track_generator, track_lengths: list | np.ndarray | int, initial_positions: np.ndarray, starting_frames: int, diffusion_parameters: np.ndarray, hurst_parameters: np.ndarray) -&gt; tuple[dict, dict]</code>:</p> </li> <li> <p>Generates tracks without state transitions.</p> </li> <li> <p><code>_generate_transition_tracks(track_generator: Track_generator, track_lengths: list | np.ndarray | int, initial_positions: np.ndarray, starting_frames: int, diffusion_parameters: np.ndarray, hurst_parameters: np.ndarray, diffusion_transition_matrix: np.ndarray, hurst_transition_matrix: np.ndarray, diffusion_state_probability: np.ndarray, hurst_state_probability: np.ndarray) -&gt; tuple[dict, dict]</code>:</p> </li> <li> <p>Generates tracks with state transitions.</p> </li> <li> <p><code>_convert_tracks_to_trajectory(tracks: dict) -&gt; dict</code>:</p> </li> <li>Converts tracks to a trajectory format.</li> </ul>"},{"location":"API_Documentation/core/motion/track_gen/#dependencies","title":"Dependencies","text":"<ul> <li><code>random</code></li> <li><code>numpy</code> (<code>np</code>)</li> <li><code>RectangularCell</code>, <code>RodCell</code>, <code>SphericalCell</code> from <code>..cells</code></li> <li><code>FBM_BP</code> from <code>.movement.fbm_BP</code></li> </ul>"},{"location":"API_Documentation/core/motion/track_gen/#usage","title":"Usage","text":"<p>To use the <code>Track_generator</code> class, instantiate it with a cell object and the necessary parameters. Then, use the provided methods to generate tracks with or without transitions.</p> <pre><code>from track_gen import Track_generator\nfrom ..cells.rectangular_cell import RectangularCell\n\n# Example usage\ncell = RectangularCell()\ntrack_generator = Track_generator(cell, cycle_count=100, exposure_time=10, interval_time=5, oversample_motion_time=2)\n\n# Generate a track with no transitions\ntrack_data = track_generator.track_generation_no_transition(\n    diffusion_coefficient=1.0,\n    hurst_exponent=0.5,\n    track_length=100,\n    initials=np.array([0, 0, 0]),\n    start_time=0\n)\n\nprint(track_data)\n</code></pre> <p>This will output a dictionary containing the generated track data.</p>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/","title":"Boundary conditions","text":""},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#documentation-for-boundary_conditionspy","title":"Documentation for <code>boundary_conditions.py</code>","text":""},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#overview","title":"Overview","text":"<p>The <code>boundary_conditions.py</code> module provides functions to handle boundary conditions for fractional Brownian motion (FBM) simulations. These functions ensure that the FBM trajectory remains within specified space limits by applying either reflecting or absorbing boundary conditions.</p>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#_refecting_boundary","title":"<code>_refecting_boundary</code>","text":"<pre><code>@_catch_recursion_error\ndef _refecting_boundary(\n    fbm_store_last: float, fbm_candidate: float, space_lim: np.ndarray\n) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#description","title":"Description","text":"<p>Applies a reflecting boundary condition to the FBM simulation. If the candidate value exceeds the space limits, the function recursively adjusts the value by reflecting it back into the allowed space.</p>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#parameters","title":"Parameters","text":"<ul> <li>fbm_store_last (<code>float</code>): The last value of the FBM trajectory.</li> <li>fbm_candidate (<code>float</code>): The candidate value for the next step in the FBM trajectory.</li> <li>space_lim (<code>np.ndarray</code>): A 2-element array representing the minimum and maximum space limits.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#returns","title":"Returns","text":"<ul> <li>float: The new value for the FBM trajectory, adjusted by the reflecting boundary condition.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#_absorbing_boundary","title":"<code>_absorbing_boundary</code>","text":"<pre><code>@_catch_recursion_error\ndef _absorbing_boundary(\n    fbm_store_last: float, fbm_candidate: float, space_lim: np.ndarray\n) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#description_1","title":"Description","text":"<p>Applies an absorbing boundary condition to the FBM simulation. If the candidate value exceeds the space limits, the function sets the value to the boundary limit.</p>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#parameters_1","title":"Parameters","text":"<ul> <li>fbm_store_last (<code>float</code>): The last value of the FBM trajectory.</li> <li>fbm_candidate (<code>float</code>): The candidate value for the next step in the FBM trajectory.</li> <li>space_lim (<code>np.ndarray</code>): A 2-element array representing the minimum and maximum space limits.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/boundary_conditions/#returns_1","title":"Returns","text":"<ul> <li>float: The new value for the FBM trajectory, adjusted by the absorbing boundary condition.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/","title":"fbm BP","text":""},{"location":"API_Documentation/core/motion/movement/fbm_BP/#documentation-for-fbm_bppy","title":"Documentation for <code>fbm_BP.py</code>","text":""},{"location":"API_Documentation/core/motion/movement/fbm_BP/#overview","title":"Overview","text":"<p>The <code>fbm_BP.py</code> module provides a class and utility functions for simulating fractional Brownian motion (FBM) with Markov processes for diffusion coefficients and Hurst exponents. The module also includes functionality to apply boundary conditions to the FBM trajectory.</p>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/motion/movement/fbm_BP/#fbm_bp","title":"<code>FBM_BP</code>","text":"<pre><code>class FBM_BP:\n</code></pre>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#description","title":"Description","text":"<p>Simulates fractional Brownian motion (FBM) using a Markov process for diffusion coefficients and Hurst exponents. The class allows for adjustable parameters and boundary conditions to control the simulation.</p>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#parameters","title":"Parameters","text":"<ul> <li>n (<code>int</code>): Number of time steps in the simulation.</li> <li>dt (<code>float</code>): Time step duration in milliseconds.</li> <li>diffusion_parameters (<code>np.ndarray</code>): Array of diffusion coefficients for the FBM simulation.</li> <li>hurst_parameters (<code>np.ndarray</code>): Array of Hurst exponents for the FBM simulation.</li> <li>diffusion_parameter_transition_matrix (<code>np.ndarray</code>): Transition matrix for diffusion coefficients.</li> <li>hurst_parameter_transition_matrix (<code>np.ndarray</code>): Transition matrix for Hurst exponents.</li> <li>state_probability_diffusion (<code>np.ndarray</code>): Initial probabilities of different diffusion states.</li> <li>state_probability_hurst (<code>np.ndarray</code>): Initial probabilities of different Hurst states.</li> <li>space_lim (<code>np.ndarray</code>): Space limits (min, max) for the FBM.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#methods","title":"Methods","text":"<ul> <li><code>_autocovariance(k: int, hurst: float) -&gt; float</code>:</li> <li> <p>Computes the autocovariance function for fractional Gaussian noise (fGn).</p> </li> <li> <p><code>_setup() -&gt; None</code>:</p> </li> <li> <p>Precomputes the autocovariance matrix and sets up initial diffusion and Hurst parameters.</p> </li> <li> <p><code>fbm() -&gt; np.ndarray</code>:</p> </li> <li>Runs the FBM simulation and returns the positions at each time step.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/motion/movement/fbm_BP/#_boundary_conditions","title":"<code>_boundary_conditions</code>","text":"<pre><code>def _boundary_conditions(\n    fbm_store_last: float,\n    fbm_candidate: float,\n    space_lim: np.ndarray,\n    condition_type: str,\n) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#description_1","title":"Description","text":"<p>Applies boundary conditions to the FBM simulation. The function selects the appropriate boundary condition (reflecting or absorbing) based on the <code>condition_type</code> parameter.</p>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#parameters_1","title":"Parameters","text":"<ul> <li>fbm_store_last (<code>float</code>): The last value of the FBM trajectory.</li> <li>fbm_candidate (<code>float</code>): The candidate value for the next step in the FBM trajectory.</li> <li>space_lim (<code>np.ndarray</code>): A 2-element array representing the minimum and maximum space limits.</li> <li>condition_type (<code>str</code>): The type of boundary condition to apply, either \"reflecting\" or \"absorbing\".</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#returns","title":"Returns","text":"<ul> <li>float: The new value for the FBM trajectory, adjusted by the specified boundary condition.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#raises","title":"Raises","text":"<ul> <li>ValueError: If the <code>condition_type</code> is not one of the supported boundary conditions.</li> </ul>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#constants","title":"Constants","text":""},{"location":"API_Documentation/core/motion/movement/fbm_BP/#boundary_conditions","title":"<code>BOUNDARY_CONDITIONS</code>","text":"<pre><code>BOUNDARY_CONDITIONS = {\n    \"reflecting\": _refecting_boundary,\n    \"absorbing\": _absorbing_boundary,\n}\n</code></pre>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#description_2","title":"Description","text":"<p>A dictionary mapping boundary condition types to their corresponding functions. This allows for easy selection of boundary conditions during the simulation.</p>"},{"location":"API_Documentation/core/motion/movement/fbm_BP/#keys","title":"Keys","text":"<ul> <li>\"reflecting\": Reflecting boundary condition.</li> <li>\"absorbing\": Absorbing boundary condition.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/","title":"Detectors","text":""},{"location":"API_Documentation/core/optics/camera/detectors/#documentation-for-detectorspy","title":"Documentation for <code>detectors.py</code>","text":""},{"location":"API_Documentation/core/optics/camera/detectors/#overview","title":"Overview","text":"<p>The <code>detectors.py</code> module provides a framework for simulating different types of microscopy camera detectors, such as EMCCD and CMOS detectors. It includes functionality for calculating photon noise, converting electrons to digital counts (ADU), and capturing frames with various detector parameters.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/optics/camera/detectors/#photon_noise","title":"<code>photon_noise</code>","text":"<pre><code>@overload\ndef photon_noise(photons: float) -&gt; float: ...\n@overload\ndef photon_noise(photons: np.ndarray) -&gt; np.ndarray: ...\ndef photon_noise(photons: np.ndarray | float) -&gt; np.ndarray | float:\n    \"\"\"\n    Calculate photons with Poisson noise.\n    \"\"\"\n    # non-negative floats\n    return np.random.poisson(lam=photons)\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/detectors/#description","title":"Description","text":"<p>The <code>photon_noise</code> function calculates photons with Poisson noise, which is a common model for photon detection in microscopy. The function supports both scalar and array inputs.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#parameters","title":"Parameters","text":"<ul> <li>photons: <code>float</code> or <code>np.ndarray</code>   The number of photons (or array of photon counts) to which Poisson noise will be applied.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/#returns","title":"Returns","text":"<ul> <li><code>float</code> or <code>np.ndarray</code>   The photon count(s) with Poisson noise added.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/camera/detectors/#detector","title":"<code>Detector</code>","text":"<pre><code>class Detector(ABC):\n    \"\"\"Base class for microscopy camera detectors.\"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/detectors/#description_1","title":"Description","text":"<p>The <code>Detector</code> class is an abstract base class that defines the common interface and behavior for all types of microscopy camera detectors. It includes methods for initializing detector parameters, converting electrons to digital counts, and capturing frames.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#attributes","title":"Attributes","text":"<ul> <li>pixel_size: <code>float</code>   Size of each pixel in microns.</li> <li>dark_current: <code>float</code>   Dark current in electrons/pixel/second.</li> <li>readout_noise: <code>float</code>   RMS readout noise in electrons.</li> <li>pixel_count: <code>Tuple[int, int]</code>   Tuple of (width, height) in pixels.</li> <li>pixel_detector_size: <code>float | int</code>   Size of the detector in microns.</li> <li>magnification: <code>float | int</code>   Magnification of the microscope.</li> <li>bit_depth: <code>int</code> (default: <code>16</code>)   Number of bits for analog-to-digital conversion.</li> <li>sensitivity: <code>float</code> (default: <code>1.0</code>)   Conversion gain in electrons/ADU.</li> <li>base_adu: <code>int</code> (default: <code>100</code>)   Base ADU to avoid negative values due to photon arrival rate.</li> <li>binning_size: <code>int</code> (default: <code>1</code>)   Binning size for combining pixels.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/#methods","title":"Methods","text":"<ul> <li><code>__init__</code></li> </ul> <p><code>python   def __init__(       self,       pixel_size: float,       dark_current: float,       readout_noise: float,       pixel_count: Tuple[int, int],       pixel_detector_size: float | int,       magnification: float | int,       bit_depth: int = 16,       sensitivity: float = 1.0,       base_adu: int = 100,       binning_size: int = 1,   ):</code></p> <p>Initializes the detector with the given parameters.</p> <ul> <li><code>base_frame</code></li> </ul> <p><code>python   def base_frame(self, base_adu: int) -&gt; np.ndarray:</code></p> <p>Creates a base frame with the specified base ADU value.</p> <ul> <li><code>electrons_to_counts</code></li> </ul> <p><code>python   def electrons_to_counts(self, electrons: np.ndarray) -&gt; np.ndarray:</code></p> <p>Converts electrons to digital counts (ADU).</p> <ul> <li><code>clipADU</code></li> </ul> <p><code>python   def clipADU(self, counts: np.ndarray) -&gt; np.ndarray:</code></p> <p>Clips the digital counts to the valid range based on the bit depth.</p> <ul> <li><code>capture_frame</code> (Abstract Method)</li> </ul> <p><code>python   @abstractmethod   def capture_frame(self, photons: np.ndarray, exposure_time: float) -&gt; np.ndarray:</code></p> <p>Captures a frame with the detector. This method must be implemented by subclasses.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#emccddetector","title":"<code>EMCCDDetector</code>","text":"<pre><code>class EMCCDDetector(Detector):\n    \"\"\"Electron Multiplying CCD detector implementation.\"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/detectors/#description_2","title":"Description","text":"<p>The <code>EMCCDDetector</code> class extends the <code>Detector</code> class to implement an Electron Multiplying CCD (EMCCD) detector. It includes additional parameters and functionality specific to EMCCD detectors, such as electron multiplication gain and clock-induced charge.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#attributes_1","title":"Attributes","text":"<ul> <li>em_gain: <code>float</code>   Electron multiplication gain.</li> <li>clock_induced_charge: <code>float</code>   Clock-induced charge in electrons/pixel/frame.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/#methods_1","title":"Methods","text":"<ul> <li><code>__init__</code></li> </ul> <p><code>python   def __init__(       self,       pixel_size: float,       dark_current: float,       readout_noise: float,       pixel_count: Tuple[int, int],       em_gain: float,       clock_induced_charge: float,       pixel_detector_size: float | int,       magnification: float | int,       sensitivity: float = 1.0,       bit_depth: int = 16,       base_adu: int = 0,       binning_size: int = 1,   ):</code></p> <p>Initializes the EMCCD detector with the given parameters.</p> <ul> <li><code>capture_frame</code></li> </ul> <p><code>python   def capture_frame(self, photons: np.ndarray, exposure_time: float) -&gt; np.ndarray:</code></p> <p>Captures a frame with the EMCCD detector, applying electron multiplication gain and clock-induced charge.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#cmosdetector","title":"<code>CMOSDetector</code>","text":"<pre><code>class CMOSDetector(Detector):\n    \"\"\"CMOS detector implementation.\"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/detectors/#description_3","title":"Description","text":"<p>The <code>CMOSDetector</code> class extends the <code>Detector</code> class to implement a CMOS detector. It includes functionality specific to CMOS detectors.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#methods_2","title":"Methods","text":"<ul> <li><code>__init__</code></li> </ul> <p><code>python   def __init__(       self,       pixel_size: float,       dark_current: float,       readout_noise: float,       pixel_count: Tuple[int, int],       pixel_detector_size: float | int,       magnification: float | int,       sensitivity: float = 1.0,       bit_depth: int = 16,       base_adu: int = 0,       binning_size: int = 1,   ):</code></p> <p>Initializes the CMOS detector with the given parameters.</p> <ul> <li><code>capture_frame</code></li> </ul> <p><code>python   def capture_frame(self, photons: np.ndarray, exposure_time: float) -&gt; np.ndarray:</code></p> <p>Captures a frame with the CMOS detector.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#create_binning_function","title":"<code>create_binning_function</code>","text":"<pre><code>def create_binning_function(input_shape, binning_size, mode=\"sum\"):\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/detectors/#description_4","title":"Description","text":"<p>Creates an optimized partial function for binning arrays of a specific shape.</p>"},{"location":"API_Documentation/core/optics/camera/detectors/#parameters_1","title":"Parameters","text":"<ul> <li>input_shape: <code>tuple</code>   Shape of the input arrays that will be binned.</li> <li>binning_size: <code>int</code>   Size of the binning window (e.g., 2 for 2x2 binning).</li> <li>mode: <code>str</code> (default: <code>\"sum\"</code>)   Method for binning. Currently only supports <code>\"sum\"</code>.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/detectors/#returns_1","title":"Returns","text":"<ul> <li><code>function</code>   A specialized function that only takes an array as input and performs binning.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/","title":"Quantum eff","text":""},{"location":"API_Documentation/core/optics/camera/quantum_eff/#documentation-for-quantum_effpy","title":"Documentation for <code>quantum_eff.py</code>","text":""},{"location":"API_Documentation/core/optics/camera/quantum_eff/#overview","title":"Overview","text":"<p>The <code>quantum_eff.py</code> module provides a class for representing and working with the quantum efficiency (QE) curve of a detector. The quantum efficiency is a measure of how effectively a detector converts incident photons into detectable electrons.</p>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/camera/quantum_eff/#quantumefficiency","title":"<code>QuantumEfficiency</code>","text":"<pre><code>@dataclass\nclass QuantumEfficiency:\n    \"\"\"\n    Represents the quantum efficiency curve of a detector.\n\n    The wavelength values should be specified in nanometers (nm).\n    \"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#description","title":"Description","text":"<p>The <code>QuantumEfficiency</code> class represents the quantum efficiency curve of a detector. It allows for the specification of quantum efficiency values at specific wavelengths and provides functionality for interpolating the quantum efficiency at arbitrary wavelengths.</p>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#attributes","title":"Attributes","text":"<ul> <li>wavelength_qe: <code>Dict[float, float]</code>   A dictionary mapping wavelengths (in nanometers) to their corresponding quantum efficiency values.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#methods","title":"Methods","text":"<ul> <li><code>__post_init__</code></li> </ul> <p><code>python   def __post_init__(self):</code></p> <p>Validates the quantum efficiency values and wavelengths, and initializes numpy arrays for faster interpolation.</p> <ul> <li><code>get_qe</code></li> </ul> <p><code>python   def get_qe(self, wavelength: float) -&gt; float:</code></p> <p>Gets the quantum efficiency for a specific wavelength using linear interpolation.</p>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#parameters","title":"Parameters","text":"<ul> <li>wavelength: <code>float</code>   The wavelength in nanometers.</li> </ul>"},{"location":"API_Documentation/core/optics/camera/quantum_eff/#returns","title":"Returns","text":"<ul> <li><code>float</code>   The interpolated quantum efficiency value between 0 and 1.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/","title":"Filters","text":""},{"location":"API_Documentation/core/optics/filters/filters/#documentation-for-filterspy","title":"Documentation for <code>filters.py</code>","text":"<p>This module provides classes and functions for representing and creating optical filters, including bandpass, top-hat, and all-pass filters. The module uses <code>numpy</code> for numerical operations and <code>pydantic</code> for data validation and serialization.</p>"},{"location":"API_Documentation/core/optics/filters/filters/#type-aliases","title":"Type Aliases","text":""},{"location":"API_Documentation/core/optics/filters/filters/#customndarray","title":"<code>CustomNDarray</code>","text":"<pre><code>CustomNDarray: TypeAlias = NDArray[np.float64]\n</code></pre> <p>A type alias for a <code>numpy</code> array of <code>float64</code> values.</p>"},{"location":"API_Documentation/core/optics/filters/filters/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/filters/filters/#filterspectrum","title":"<code>FilterSpectrum</code>","text":"<pre><code>class FilterSpectrum(BaseModel):\n    \"\"\"Represents the spectral characteristics of an optical filter\"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/filters/filters/#fields","title":"Fields","text":"<ul> <li> <p><code>wavelengths</code>: <code>NDArray[np.float64]</code>   Wavelengths in nanometers.</p> </li> <li> <p><code>transmission</code>: <code>NDArray[np.float64]</code>   Transmission values (0-1).</p> </li> <li> <p><code>cached_transmissions</code>: <code>Dict[float, float]</code>   A dictionary to cache computed transmission values for future lookups. This field is excluded from serialization.</p> </li> <li> <p><code>name</code>: <code>str</code>   The name of the filter.</p> </li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#validators","title":"Validators","text":"<ul> <li> <p><code>validate_transmission</code>: Ensures that all transmission values are between 0 and 1. Raises a <code>ValueError</code> if invalid values are found.</p> </li> <li> <p><code>validate_wavelengths</code>: Ensures that all wavelengths are positive and strictly increasing. Raises a <code>ValueError</code> if invalid values are found.</p> </li> <li> <p><code>validate_array_lengths</code>: Ensures that the <code>wavelengths</code> and <code>transmission</code> arrays have the same length. Raises a <code>ValueError</code> if they do not match.</p> </li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#methods","title":"Methods","text":"<ul> <li> <p><code>find_transmission(wavelength: float) -&gt; float</code>   Finds the transmission value for a given wavelength using interpolation. Caches computed values for future lookups.</p> </li> <li> <p>Args:</p> <ul> <li><code>wavelength</code>: The wavelength in nanometers.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li>The interpolated transmission value between 0 and 1.</li> </ul> </li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#configuration","title":"Configuration","text":"<ul> <li><code>Config</code>: Allows arbitrary types to be used in the model.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#filterset","title":"<code>FilterSet</code>","text":"<pre><code>class FilterSet(BaseModel):\n    \"\"\"Represents a complete filter set (excitation, dichroic, emission)\"\"\"\n</code></pre>"},{"location":"API_Documentation/core/optics/filters/filters/#fields_1","title":"Fields","text":"<ul> <li> <p><code>excitation</code>: <code>FilterSpectrum</code>   The excitation filter.</p> </li> <li> <p><code>dichroic</code>: <code>FilterSpectrum</code>   The dichroic filter.</p> </li> <li> <p><code>emission</code>: <code>FilterSpectrum</code>   The emission filter.</p> </li> <li> <p><code>name</code>: <code>str</code>   The name of the filter set (default: \"Generic Filter Set\").</p> </li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/optics/filters/filters/#create_bandpass_filter","title":"<code>create_bandpass_filter</code>","text":"<pre><code>def create_bandpass_filter(\n    center_wavelength: float,\n    bandwidth: float,\n    transmission_peak: float = 0.95,\n    points: int = 1000,\n    name: Optional[str] = None,\n) -&gt; FilterSpectrum:\n    \"\"\"\n    Create a gaussian-shaped bandpass filter\n    \"\"\"\n</code></pre> <p>Creates a Gaussian-shaped bandpass filter.</p> <ul> <li>Args:</li> <li><code>center_wavelength</code>: Center wavelength in nanometers.</li> <li><code>bandwidth</code>: FWHM bandwidth in nanometers.</li> <li><code>transmission_peak</code>: Peak transmission (0-1) (default: 0.95).</li> <li><code>points</code>: Number of points in the spectrum (default: 1000).</li> <li> <p><code>name</code>: Optional name for the filter.</p> </li> <li> <p>Returns:</p> </li> <li>A <code>FilterSpectrum</code> object representing the bandpass filter.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#create_tophat_filter","title":"<code>create_tophat_filter</code>","text":"<pre><code>def create_tophat_filter(\n    center_wavelength: float,\n    bandwidth: float,\n    transmission_peak: float = 0.95,\n    edge_steepness: float = 5.0,\n    points: int = 1000,\n    name: Optional[str] = None,\n) -&gt; FilterSpectrum:\n    \"\"\"\n    Create a top-hat (rectangular) shaped filter with smooth edges\n    \"\"\"\n</code></pre> <p>Creates a top-hat (rectangular) shaped filter with smooth edges.</p> <ul> <li>Args:</li> <li><code>center_wavelength</code>: Center wavelength in nanometers.</li> <li><code>bandwidth</code>: Width of the passband in nanometers (FWHM).</li> <li><code>transmission_peak</code>: Peak transmission (0-1) (default: 0.95).</li> <li><code>edge_steepness</code>: Controls the sharpness of the edges (higher = sharper) (default: 5.0).</li> <li><code>points</code>: Number of points in the spectrum (default: 1000).</li> <li> <p><code>name</code>: Optional name for the filter.</p> </li> <li> <p>Returns:</p> </li> <li>A <code>FilterSpectrum</code> object representing the top-hat filter.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#create_allow_all_filter","title":"<code>create_allow_all_filter</code>","text":"<pre><code>def create_allow_all_filter(points: int, name: Optional[str] = None) -&gt; FilterSpectrum:\n    \"\"\"\n    Create a filter that allows all wavelengths\n    \"\"\"\n</code></pre> <p>Creates a filter that allows all wavelengths.</p> <ul> <li>Args:</li> <li><code>points</code>: Number of points in the spectrum.</li> <li> <p><code>name</code>: Optional name for the filter.</p> </li> <li> <p>Returns:</p> </li> <li>A <code>FilterSpectrum</code> object representing the all-pass filter.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/filters/#usage-example","title":"Usage Example","text":"<pre><code># Create a bandpass filter\nbandpass_filter = create_bandpass_filter(center_wavelength=500, bandwidth=50)\n\n# Create a top-hat filter\ntophat_filter = create_tophat_filter(center_wavelength=600, bandwidth=40)\n\n# Create an all-pass filter\nall_pass_filter = create_allow_all_filter(points=500)\n\n# Create a filter set\nfilter_set = FilterSet(\n    excitation=bandpass_filter,\n    dichroic=tophat_filter,\n    emission=all_pass_filter,\n    name=\"My Filter Set\"\n)\n\n# Find transmission for a specific wavelength\ntransmission = filter_set.excitation.find_transmission(wavelength=520)\nprint(transmission)\n</code></pre>"},{"location":"API_Documentation/core/optics/filters/filters/#notes","title":"Notes","text":"<ul> <li>The <code>FilterSpectrum</code> class uses <code>pydantic</code> for data validation, ensuring that wavelengths and transmission values are valid.</li> <li>The <code>cached_transmissions</code> field in <code>FilterSpectrum</code> improves performance by caching interpolated transmission values.</li> <li>The <code>create_*_filter</code> functions provide convenient ways to generate common filter shapes.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/","title":"Channelschema","text":""},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#module-channelsschemapy","title":"Module: <code>channelsschema.py</code>","text":"<p>This module defines a Pydantic model for representing a collection of channels, including their associated filter sets, splitting efficiencies, and names.</p>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#channels","title":"<code>Channels</code>","text":"<p>A Pydantic model representing a collection of channels.</p>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#attributes","title":"Attributes","text":"<ul> <li><code>filtersets</code>: <code>List[FilterSet]</code></li> <li> <p>A list of <code>FilterSet</code> objects, each representing a set of filters for a channel.</p> </li> <li> <p><code>num_channels</code>: <code>int</code></p> </li> <li> <p>The number of channels. This value must match the length of the <code>filtersets</code> and <code>splitting_efficiency</code> lists.</p> </li> <li> <p><code>splitting_efficiency</code>: <code>List[float]</code></p> </li> <li> <p>A list of floats representing the splitting efficiency for each channel. The length of this list must match the <code>num_channels</code>.</p> </li> <li> <p><code>names</code>: <code>List[str]</code></p> </li> <li>A list of strings representing the names of the channels.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#validation","title":"Validation","text":"<ul> <li><code>num_channels</code>:</li> <li>The <code>num_channels</code> attribute is validated to ensure that it matches the length of the <code>filtersets</code> and <code>splitting_efficiency</code> lists. If the lengths do not match, a <code>ValueError</code> is raised.</li> </ul>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#example","title":"Example","text":"<pre><code>from channelsschema import Channels\nfrom ....optics.filters.filters import FilterSet\n\n# Example usage\nchannels = Channels(\n    filtersets=[FilterSet(...), FilterSet(...)],\n    num_channels=2,\n    splitting_efficiency=[0.8, 0.9],\n    names=[\"Channel 1\", \"Channel 2\"]\n)\n</code></pre>"},{"location":"API_Documentation/core/optics/filters/channels/channelschema/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>:</li> <li>If <code>num_channels</code> does not match the length of <code>filtersets</code>.</li> <li>If <code>num_channels</code> does not match the length of <code>splitting_efficiency</code>.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/","title":"Laser profiles","text":""},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#module-laser_profilespy","title":"Module: <code>laser_profiles.py</code>","text":"<p>This module provides a comprehensive set of classes and utilities for modeling laser beam profiles, including Gaussian, widefield, HiLo, and confocal beam profiles. The module is designed to be flexible and extensible, allowing for the simulation of various laser beam characteristics and their interactions with optical systems.</p>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Classes</li> <li>Units</li> <li>LaserParameters</li> <li>LaserProfile</li> <li>GaussianBeam</li> <li>WidefieldBeam</li> <li>HiLoBeam</li> <li>ConfocalBeam</li> <li>Example Usage</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#overview","title":"Overview","text":"<p>The <code>laser_profiles.py</code> module is designed to model laser beam profiles with a focus on optical microscopy applications. It includes classes for defining laser parameters, abstract base classes for laser profiles, and concrete implementations for specific types of laser beams. The module leverages NumPy for numerical computations and supports time-dependent parameters, making it suitable for dynamic simulations.</p>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#units","title":"<code>Units</code>","text":"<pre><code>class Units(Enum):\n    \"\"\"Enumeration of supported units for laser parameters.\"\"\"\n\n    MICRONS = \"\u00b5m\"\n    WATTS = \"W\"\n</code></pre> <ul> <li>Description: Enumeration of supported units for laser parameters.</li> <li>Fields:</li> <li><code>MICRONS</code>: Represents microns.</li> <li><code>WATTS</code>: Represents watts.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#laserparameters","title":"<code>LaserParameters</code>","text":"<pre><code>@dataclass\nclass LaserParameters:\n    \"\"\"\n    Parameters defining a laser beam.\n\n    All spatial parameters are in microns unless otherwise specified.\n    \"\"\"\n\n    wavelength: float  # Wavelength in nanometers\n    power: Union[float, Callable[[float], float]]  # Power in watts\n    beam_width: float  # 1/e\u00b2 beam width at waist in microns\n    numerical_aperture: Optional[float] = None  # NA of focusing lens\n    position: Union[Tuple[float, float, float], Callable[[float], np.ndarray]] = (\n        0.0,\n        0.0,\n        0.0,\n    )\n    refractive_index: float = 1.0  # Refractive index of medium\n</code></pre> <ul> <li>Description: A dataclass that encapsulates the parameters defining a laser beam.</li> <li>Fields:</li> <li><code>wavelength</code>: Wavelength of the laser in nanometers.</li> <li><code>power</code>: Power of the laser in watts, or a callable that returns power as a function of time.</li> <li><code>beam_width</code>: 1/e\u00b2 beam width at the waist in microns.</li> <li><code>numerical_aperture</code>: Numerical aperture of the focusing lens (optional).</li> <li><code>position</code>: Position of the beam as a tuple of (x, y, z) coordinates in microns, or a callable that returns the position as a function of time.</li> <li> <p><code>refractive_index</code>: Refractive index of the medium.</p> </li> <li> <p>Methods:</p> </li> <li><code>__post_init__</code>: Validates and computes derived parameters after initialization.</li> <li><code>_validate_parameters</code>: Validates the input parameters.</li> <li><code>_compute_derived_parameters</code>: Computes derived beam parameters such as the Rayleigh range and wave number.</li> <li><code>diffraction_limited_width</code>: Calculates the diffraction-limited 1/e\u00b2 beam width in microns.</li> <li><code>get_power</code>: Returns the power at a given time.</li> <li><code>get_position</code>: Returns the beam position at a given time.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#laserprofile","title":"<code>LaserProfile</code>","text":"<pre><code>class LaserProfile(ABC):\n    \"\"\"Abstract base class for laser beam profiles.\"\"\"\n\n    def __init__(self, params: LaserParameters):\n        self.params = params\n\n    @abstractmethod\n    def calculate_intensity(\n        self,\n        x: np.ndarray | float,\n        y: np.ndarray | float,\n        z: np.ndarray | float,\n        t: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the intensity distribution at given coordinates and time.\n\n        Args:\n            x: X coordinates in microns (3D array)\n            y: Y coordinates in microns (3D array)\n            z: Z coordinates in microns (3D array)\n            t: Time in milliseconds\n\n        Returns:\n            3D array of intensities in W/m\u00b2\n        \"\"\"\n        pass\n</code></pre> <ul> <li>Description: Abstract base class for laser beam profiles.</li> <li>Methods:</li> <li><code>calculate_intensity</code>: Abstract method to calculate the intensity distribution at given coordinates and time.</li> <li><code>get_beam_width</code>: Calculates the beam width at a distance z from the waist.</li> <li><code>get_radius_of_curvature</code>: Calculates the radius of curvature at a distance z.</li> <li><code>get_gouy_phase</code>: Calculates the Gouy phase at a distance z.</li> <li><code>get_intensity_map</code>: Generates a discretized intensity map for the given volume at time t.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#gaussianbeam","title":"<code>GaussianBeam</code>","text":"<pre><code>class GaussianBeam(LaserProfile):\n    \"\"\"3D Gaussian laser beam profile with time dependence.\"\"\"\n\n    def calculate_intensity(\n        self,\n        x: np.ndarray | float,\n        y: np.ndarray | float,\n        z: np.ndarray | float,\n        t: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the Gaussian beam intensity distribution.\n\n        Args:\n            x: X coordinates in microns (3D array)\n            y: Y coordinates in microns (3D array)\n            z: Z coordinates in microns (3D array)\n            t: Time in seconds\n\n        Returns:\n            3D array of intensities in W/um\u00b2\n\n        Note:\n            Uses the paraxial approximation valid for low NA\n        \"\"\"\n        pass\n</code></pre> <ul> <li>Description: Implements a 3D Gaussian laser beam profile with time dependence.</li> <li>Methods:</li> <li><code>calculate_intensity</code>: Calculates the Gaussian beam intensity distribution.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#widefieldbeam","title":"<code>WidefieldBeam</code>","text":"<pre><code>class WidefieldBeam(LaserProfile):\n    \"\"\"\n    Widefield illumination profile where the laser beam is focused at the back focal plane\n    of the objective to create uniform illumination across the field of view.\n    \"\"\"\n\n    def calculate_intensity(\n        self,\n        x: np.ndarray | float,\n        y: np.ndarray | float,\n        z: np.ndarray | float,\n        t: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the widefield illumination intensity distribution.\n\n        Args:\n            x: X coordinates in microns (3D array)\n            y: Y coordinates in microns (3D array)\n            z: Z coordinates in microns (3D array)\n            t: Time in seconds\n\n        Returns:\n            3D array of intensities in W/\u00b5m\u00b2\n        \"\"\"\n        pass\n</code></pre> <ul> <li>Description: Implements a widefield illumination profile.</li> <li>Methods:</li> <li><code>calculate_intensity</code>: Calculates the widefield illumination intensity distribution.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#hilobeam","title":"<code>HiLoBeam</code>","text":"<pre><code>class HiLoBeam(LaserProfile):\n    \"\"\"\n    Highly Inclined Laminated Optical (HiLo) illumination profile.\n\n    HiLo microscopy uses an oblique, tilted illumination angle to reduce\n    out-of-focus background while maintaining high contrast for thin specimens.\n    \"\"\"\n\n    def calculate_intensity(\n        self,\n        x: np.ndarray | float,\n        y: np.ndarray | float,\n        z: np.ndarray | float,\n        t: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the HiLo illumination intensity distribution.\n\n        Args:\n            x: X coordinates in microns (3D array)\n            y: Y coordinates in microns (3D array)\n            z: Z coordinates in microns (3D array)\n            t: Time in seconds\n\n        Returns:\n            3D array of intensities in W/\u00b5m\u00b2\n        \"\"\"\n        pass\n</code></pre> <ul> <li>Description: Implements a HiLo illumination profile.</li> <li>Methods:</li> <li><code>calculate_intensity</code>: Calculates the HiLo illumination intensity distribution.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#confocalbeam","title":"<code>ConfocalBeam</code>","text":"<pre><code>class ConfocalBeam(LaserProfile):\n    \"\"\"\n    Confocal microscopy beam profile with point scanning and pinhole characteristics.\n\n    Implements key optical principles of confocal microscopy:\n    - Point scanning illumination\n    - Pinhole-based rejection of out-of-focus light\n    - Depth-resolved imaging capabilities\n    \"\"\"\n\n    def calculate_intensity(\n        self,\n        x: np.ndarray | float,\n        y: np.ndarray | float,\n        z: np.ndarray | float,\n        t: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the confocal illumination intensity distribution.\n\n        Args:\n            x: X coordinates in microns (3D array)\n            y: Y coordinates in microns (3D array)\n            z: Z coordinates in microns (3D array)\n            t: Time in seconds\n\n        Returns:\n            3D array of intensities in W/\u00b5m\u00b2\n        \"\"\"\n        pass\n</code></pre> <ul> <li>Description: Implements a confocal microscopy beam profile.</li> <li>Methods:</li> <li><code>calculate_intensity</code>: Calculates the confocal illumination intensity distribution.</li> </ul>"},{"location":"API_Documentation/core/optics/lasers/laser_profiles/#example-usage","title":"Example Usage","text":"<pre><code>if __name__ == \"__main__\":\n    # Create parameters for a typical microscope objective\n    params = LaserParameters(\n        wavelength=488,  # 488 nm\n        power=0.001,  # 1 mW\n        beam_width=0.25,  # 250 nm\n        numerical_aperture=1.4,\n        refractive_index=1.518,  # Oil immersion\n    )\n\n    # Create beam object\n    beam = GaussianBeam(params)\n\n    # Get intensity map\n    result = beam.get_intensity_map(\n        volume_size=(5, 5, 10),  # 5x5x10 microns\n        voxel_size=0.1,  # 100 nm voxels\n        t=0,  # t=0 seconds\n    )\n</code></pre> <p>This example demonstrates how to create a <code>LaserParameters</code> object, instantiate a <code>GaussianBeam</code>, and generate an intensity map for a given volume.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/","title":"Psf engine","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#psf_enginepy-documentation","title":"<code>psf_engine.py</code> Documentation","text":"<p>This module provides functionality for generating Point Spread Functions (PSFs) for microscopy using Gaussian approximations. It includes classes and functions to define PSF parameters, initialize calculations, and generate 2D and 3D PSFs.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Classes</li> <li>PSFParameters</li> <li>PSFEngine</li> <li>Functions</li> <li>_calculate_sigma_xy</li> <li>_calculate_sigma_z</li> <li>_generate_grid</li> <li>calculate_psf_size</li> <li>_generate_pinhole_mask</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#psfparameters","title":"<code>PSFParameters</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description","title":"Description","text":"<p>This is a frozen dataclass (enum-ish?) with the following parameters / cached properties</p> <pre><code>emission_wavelength: float\nnumerical_aperture: float\npixel_size: float\nz_step: float\nrefractive_index: float = 1.0\npinhole_diameter: Optional[float] = None  # um\n\n@cached_property\ndef wavelength_um(self) -&gt; float:\n    \"\"\"Emission wavelength in micrometers.\"\"\"\n    return self.emission_wavelength / 1000.0\n@cached_property\ndef pinhole_radius(self) -&gt; Optional[float]:\n  \"\"\"Pinhole radius in micrometers.\"\"\"\n  return (\n    self.pinhole_diameter / 2.0 if self.pinhole_diameter is not None else None\n  )\n</code></pre>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#psfengine","title":"<code>PSFEngine</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#methods","title":"Methods","text":"<ul> <li><code>__init__</code>: Initializes the PSF engine with the given parameters.</li> <li><code>_initialize_calculations</code>: Initializes commonly used calculations for PSF generation.</li> <li><code>psf_z</code>: Generates a 2D Gaussian approximation of the PSF at a specific z-position.</li> <li><code>psf_z_xy0</code>: Generates a Gaussian approximation of the PSF at a specific z-position with x=y=0.</li> <li><code>_3d_normalization_A</code>: Computes the normalization factor for a 3D Gaussian PSF.</li> <li><code>_2d_normalization_A</code>: Computes the normalization factor for a 2D Gaussian PSF.</li> <li><code>normalize_psf</code>: Normalizes the PSF using different schemes.</li> <li><code>_generate_pinhole_mask</code>: Generate a binary mask representing the pinhole's spatial filtering.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#_calculate_sigma_xy","title":"<code>_calculate_sigma_xy</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description_1","title":"Description","text":"<p>Calculates the lateral sigma value for the PSF.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#parameters","title":"Parameters","text":"<ul> <li><code>wavelength_um</code>: Wavelength in micrometers.</li> <li><code>numerical_aperture</code>: Numerical aperture of the optical system.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#returns","title":"Returns","text":"<ul> <li><code>float</code>: Lateral sigma value.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#_calculate_sigma_z","title":"<code>_calculate_sigma_z</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description_2","title":"Description","text":"<p>Calculates the axial sigma value for the PSF.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#parameters_1","title":"Parameters","text":"<ul> <li><code>wavelength_um</code>: Wavelength in micrometers.</li> <li><code>numerical_aperture</code>: Numerical aperture of the optical system.</li> <li><code>refractive_index</code>: Refractive index of the medium.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#returns_1","title":"Returns","text":"<ul> <li><code>float</code>: Axial sigma value.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#_generate_grid","title":"<code>_generate_grid</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description_3","title":"Description","text":"<p>Generates coordinate grids for PSF calculation.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#parameters_2","title":"Parameters","text":"<ul> <li><code>size</code>: Tuple of (height, width) for the grid.</li> <li><code>pixel_size</code>: Size of pixels in micrometers.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#returns_2","title":"Returns","text":"<ul> <li><code>Tuple[NDArray[np.float64], NDArray[np.float64]]</code>: Tuple of x and y coordinate arrays.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#calculate_psf_size","title":"<code>calculate_psf_size</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description_4","title":"Description","text":"<p>Calculates the appropriate PSF size based on physical parameters.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#parameters_3","title":"Parameters","text":"<ul> <li><code>sigma_xy</code>: Lateral sigma value.</li> <li><code>pixel_size</code>: Size of pixels in micrometers.</li> <li><code>sigma_z</code>: Axial sigma value.</li> <li><code>z_size</code>: Optional number of z-planes for 3D PSF.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#returns_3","title":"Returns","text":"<ul> <li><code>Tuple[int, ...]</code>: Tuple of dimensions (z, y, x) or (y, x) for the PSF calculation.</li> </ul>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#_generate_pinhole_mask","title":"<code>_generate_pinhole_mask</code>","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#description_5","title":"Description","text":"<p>Generate a binary mask representing the pinhole's spatial filtering.</p> <p>The pinhole blocks emission light based on position in the image plane, affecting what portion of the diffracted light reaches the detector.</p>"},{"location":"API_Documentation/core/optics/psf/psf_engine/#parameters_4","title":"Parameters","text":""},{"location":"API_Documentation/core/optics/psf/psf_engine/#returns_4","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code>: Same dimensions as the psf generated but with binary values (0,1) indicating the transmittance of the psf due to the pinhole. Note, if the pinhole size is smaller than 1*airy disk diameter, then diffraction due to the pinhole is NOT non negligiable and diffraction effects will be introduced. A ValueError is thrown if this is the case.   </li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/","title":"Photon physics","text":""},{"location":"API_Documentation/core/photophysics/photon_physics/#module-documentation-photon_physicspy","title":"Module Documentation: <code>photon_physics.py</code>","text":""},{"location":"API_Documentation/core/photophysics/photon_physics/#overview","title":"Overview","text":"<p>The <code>photon_physics.py</code> module provides classes and methods for simulating photon absorption, emission, and detection processes. It includes models for absorption, emission, and incident photon calculations, as well as methods for handling quantum efficiency and PSF (Point Spread Function) effects.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/photophysics/photon_physics/#absorptionbase","title":"<code>AbsorptionBase</code>","text":"<p>A base class for calculating photon absorption processes.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#attributes","title":"Attributes:","text":"<ul> <li><code>excitation_spectrum</code> (<code>SpectralData</code>): The excitation spectrum of the fluorophore.</li> <li><code>intensity_incident</code> (<code>WavelengthDependentProperty</code>): The incident light intensity.</li> <li><code>absorb_cross_section_spectrum</code> (<code>WavelengthDependentProperty</code>): The absorption cross-section spectrum.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#methods","title":"Methods:","text":"<ul> <li><code>_calc_flux_density_precursor(self) -&gt; WavelengthDependentProperty</code>:   Calculates the flux density precursor for absorption.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#absorptionphysics","title":"<code>AbsorptionPhysics</code>","text":"<p>Extends <code>AbsorptionBase</code> to include fluorescent lifetime and saturation rate calculations.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#attributes_1","title":"Attributes:","text":"<ul> <li><code>fluorescent_lifetime_inverse</code> (<code>float</code>): The inverse of the fluorescent lifetime.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#methods_1","title":"Methods:","text":"<ul> <li> <p><code>saturation_rate(self, rate: float, max_rate: float) -&gt; float</code>:   Clips the rate to a maximum value.</p> </li> <li> <p><code>absorbed_photon_rate(self) -&gt; float</code>:   Calculates the rate of absorbed photons.</p> </li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#photostateswitchphysics","title":"<code>PhotoStateSwitchPhysics</code>","text":"<p>Extends <code>AbsorptionBase</code> for photostate switching physics.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#attributes_2","title":"Attributes:","text":"<ul> <li><code>quantum_yeild</code> (<code>float</code>): The quantum yield for photostate switching.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#emissionphysics","title":"<code>EmissionPhysics</code>","text":"<p>A class for calculating photon emission rates and transmission.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#attributes_3","title":"Attributes:","text":"<ul> <li><code>emission_spectrum</code> (<code>SpectralData</code>): The emission spectrum of the fluorophore.</li> <li><code>quantum_yield</code> (<code>WavelengthDependentProperty</code>): The quantum yield for emission.</li> <li><code>transmission_filter</code> (<code>FilterSpectrum</code>): The transmission filter spectrum.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#methods_2","title":"Methods:","text":"<ul> <li> <p><code>emission_photon_rate(self, total_absorbed_rate: float) -&gt; WavelengthDependentProperty</code>:   Calculates the rate of emitted photons.</p> </li> <li> <p><code>transmission_photon_rate(self, emission_photon_rate_lambda: WavelengthDependentProperty) -&gt; WavelengthDependentProperty</code>:   Calculates the rate of transmitted photons.</p> </li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#incident_photons","title":"<code>incident_photons</code>","text":"<p>A class for calculating incident photons based on transmission rates, quantum efficiency, and PSF.</p>"},{"location":"API_Documentation/core/photophysics/photon_physics/#attributes_4","title":"Attributes:","text":"<ul> <li><code>transmission_photon_rate</code> (<code>WavelengthDependentProperty</code>): The rate of transmitted photons.</li> <li><code>quantumEff</code> (<code>QuantumEfficiency</code>): The quantum efficiency of the detector.</li> <li><code>psf</code> (<code>Callable</code>): A function to generate the PSF.</li> <li><code>position</code> (<code>Tuple[float, float, float]</code>): The position of the fluorophore.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#methods_3","title":"Methods:","text":"<ul> <li><code>incident_photons_calc(self, dt: float) -&gt; Tuple[float, List]</code>:   Calculates the number of incident photons and their distribution.</li> </ul>"},{"location":"API_Documentation/core/photophysics/photon_physics/#dependencies","title":"Dependencies","text":"<ul> <li><code>numpy</code>: For numerical operations.</li> <li><code>pydantic</code>: For data validation and settings management.</li> <li><code>..optics.camera.detectors</code>: For photon noise calculations.</li> <li><code>..optics.camera.quantum_eff</code>: For quantum efficiency calculations.</li> <li><code>..optics.filters.filters</code>: For filter spectrum calculations.</li> <li><code>..optics.psf.psf_engine</code>: For PSF calculations.</li> <li><code>..sample.flurophores.flurophore_schema</code>: For fluorophore schema definitions.</li> <li><code>..utils.constants</code>: For physical constants.</li> </ul>"},{"location":"API_Documentation/core/photophysics/state_kinetics/","title":"State kinetics","text":""},{"location":"API_Documentation/core/photophysics/state_kinetics/#module-documentation-state_kineticspy","title":"Module Documentation: <code>state_kinetics.py</code>","text":""},{"location":"API_Documentation/core/photophysics/state_kinetics/#overview","title":"Overview","text":"<p>The <code>state_kinetics.py</code> module provides functionality for simulating state transitions of fluorescent objects using a Markov Chain Monte Carlo (MCMC) approach. It includes classes and methods to calculate state transitions, track fluorescence history, and handle errors during simulation.</p>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/photophysics/state_kinetics/#ernomsg","title":"<code>ErnoMsg</code>","text":"<p>A data model representing the result of a state transition simulation, including success status, time, and end state.</p>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#attributes","title":"Attributes:","text":"<ul> <li><code>success</code> (<code>bool</code>): Indicates whether the simulation was successful.</li> <li><code>erno_time</code> (<code>Optional[float]</code>): The time at which the error occurred (if any).</li> <li><code>erno_end_state</code> (<code>Optional[State]</code>): The state at which the error occurred (if any).</li> </ul>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#statetransitioncalculator","title":"<code>StateTransitionCalculator</code>","text":"<p>A class responsible for calculating state transitions of a fluorescent object over a given time duration.</p>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#attributes_1","title":"Attributes:","text":"<ul> <li><code>flurophoreobj</code> (<code>FluorescentObject</code>): The fluorescent object for which state transitions are calculated.</li> <li><code>time_duration</code> (<code>int | float</code>): The duration of the simulation in seconds.</li> <li><code>current_global_time</code> (<code>int</code>): The current global time in milliseconds.</li> <li><code>laser_intensity_generator</code> (<code>Callable</code>): A function to generate laser intensities.</li> <li><code>fluorescent_state_history</code> (<code>dict</code>): A dictionary tracking fluorescence state history.</li> </ul>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#methods","title":"Methods:","text":"<ul> <li> <p><code>__init__(self, flurophoreobj: FluorescentObject, time_duration: int | float, current_global_time: int, laser_intensity_generator: Callable) -&gt; None</code>:   Initializes the <code>StateTransitionCalculator</code> with the given parameters.</p> </li> <li> <p><code>__call__(self) -&gt; Tuple[dict, State, ErnoMsg]</code>:   Executes the state transition calculation and returns the fluorescence state history, final state, and error message.</p> </li> <li> <p><code>_initialize_state_hist(self, time_pos: int, time_laser: float) -&gt; dict</code>:   Initializes the state history dictionary with laser intensities.</p> </li> <li> <p><code>MCMC(self) -&gt; Tuple[State, ErnoMsg]</code>:   Performs the MCMC simulation to calculate state transitions and returns the final state and error message.</p> </li> <li> <p><code>_find_transitions(self, statename: str) -&gt; list</code>:   Cached method to find transitions from a given state.</p> </li> </ul>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/photophysics/state_kinetics/#ssa_stepreaction_rates-sequencefloat-int-tuplefloat-int","title":"<code>ssa_step(reaction_rates: Sequence[float | int]) -&gt; tuple[float, int]</code>","text":"<p>Performs one step of the Stochastic Simulation Algorithm (SSA) to determine the next reaction and time step.</p>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#parameters","title":"Parameters:","text":"<ul> <li><code>reaction_rates</code> (<code>Sequence[float | int]</code>): List of reaction rates.</li> </ul>"},{"location":"API_Documentation/core/photophysics/state_kinetics/#returns","title":"Returns:","text":"<ul> <li><code>dt</code> (<code>float</code>): The time step to advance.</li> <li><code>next_event</code> (<code>int</code>): The index of the next reaction.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/","title":"Markov chain","text":""},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#module-documentation-markov_chainpy","title":"Module Documentation: <code>markov_chain.py</code>","text":""},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#overview","title":"Overview","text":"<p>The <code>markov_chain.py</code> module provides functions for simulating Markov Chain Monte Carlo (MCMC) state transitions and utility functions for converting between rates and probabilities. The module is designed to facilitate simulations of state transitions based on a given transition matrix and to handle time-dependent probability calculations.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#mcmc_state_selection","title":"<code>MCMC_state_selection</code>","text":"<pre><code>def MCMC_state_selection(\n    initial_state_index: int,\n    transition_matrix: np.ndarray,\n    possible_states: np.ndarray,\n    n: int,\n) -&gt; np.ndarray:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#description","title":"Description","text":"<p>Simulates state transitions using a Markov Chain Monte Carlo (MCMC) method. The function selects the next state based on the current state and a transition matrix over <code>n</code> iterations. The transition matrix defines the probability of switching to a new state in each time step.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#parameters","title":"Parameters","text":"<ul> <li><code>initial_state_index</code> (<code>int</code>): The index of the initial state in the <code>possible_states</code> array.</li> <li><code>transition_matrix</code> (<code>np.ndarray</code>): A square matrix representing the transition probabilities between states.</li> <li><code>possible_states</code> (<code>np.ndarray</code>): An array of possible states for the system.</li> <li><code>n</code> (<code>int</code>): The number of iterations to perform.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code>: An array of selected states at each iteration.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#mcmc_state_selection_rate","title":"<code>MCMC_state_selection_rate</code>","text":"<pre><code>def MCMC_state_selection_rate(\n    initial_state_index: int,\n    transition_matrix: np.ndarray,  # in rate, (1/s) s= seconds\n    possible_states: np.ndarray,\n    n: int,\n    time_unit: int,  # amount of time (ms) in one n; ms = milliseconds\n):\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#description_1","title":"Description","text":"<p>Simulates state transitions using a Markov Chain Monte Carlo (MCMC) method, where the transition matrix is given in terms of rates (1/s). The function converts the rates to probabilities before performing the state selection.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#parameters_1","title":"Parameters","text":"<ul> <li><code>initial_state_index</code> (<code>int</code>): The index of the initial state in the <code>possible_states</code> array.</li> <li><code>transition_matrix</code> (<code>np.ndarray</code>): A square matrix representing the transition rates between states (in 1/s).</li> <li><code>possible_states</code> (<code>np.ndarray</code>): An array of possible states for the system.</li> <li><code>n</code> (<code>int</code>): The number of iterations to perform.</li> <li><code>time_unit</code> (<code>int</code>): The amount of time (in milliseconds) for one iteration.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code>: An array of selected states at each iteration.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#rate_to_probability","title":"<code>rate_to_probability</code>","text":"<pre><code>@cache\ndef rate_to_probability(rate: float, dt: float) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#description_2","title":"Description","text":"<p>Converts a rate (1/s) to a probability (0-1) based on a given time step.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#parameters_2","title":"Parameters","text":"<ul> <li><code>rate</code> (<code>float</code>): The rate (1/s).</li> <li><code>dt</code> (<code>float</code>): The time step (s) for the probability calculation.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#returns_2","title":"Returns","text":"<ul> <li><code>float</code>: The probability (0-1).</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#probability_to_rate","title":"<code>probability_to_rate</code>","text":"<pre><code>@cache\ndef probability_to_rate(probability: float, dt: float) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#description_3","title":"Description","text":"<p>Converts a probability (0-1) to a rate (1/s) based on a given time step.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#parameters_3","title":"Parameters","text":"<ul> <li><code>probability</code> (<code>float</code>): The probability (0-1).</li> <li><code>dt</code> (<code>float</code>): The time step (s) for the probability calculation.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#returns_3","title":"Returns","text":"<ul> <li><code>float</code>: The rate (1/s).</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#change_prob_time","title":"<code>change_prob_time</code>","text":"<pre><code>def change_prob_time(\n    probability: np.ndarray | float, dt: float, dt_prime: float\n) -&gt; np.ndarray:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#description_4","title":"Description","text":"<p>Changes the probability defined for a time step <code>dt</code> to a new time step <code>dt_prime</code>.</p>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#parameters_4","title":"Parameters","text":"<ul> <li><code>probability</code> (<code>np.ndarray | float</code>): The probability (0-1).</li> <li><code>dt</code> (<code>float</code>): The original time step (s).</li> <li><code>dt_prime</code> (<code>float</code>): The new time step (s).</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/markov_chain/#returns_4","title":"Returns","text":"<ul> <li><code>np.ndarray | float</code>: The probability adjusted for the new time step.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/","title":"Probability functions","text":""},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#module-documentation-probability_functionspy","title":"Module Documentation: <code>probability_functions.py</code>","text":""},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#overview","title":"Overview","text":"<p>The <code>probability_functions.py</code> module provides tools for handling probability distributions, particularly for \"top-hat\" shaped subspaces within a larger spatial environment. The module includes functions for generating random points based on a probability distribution and a class for managing multiple top-hat probability functions.</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#generate_points","title":"<code>generate_points</code>","text":"<pre><code>def generate_points(\n    pdf: callable,\n    total_points: int,\n    min_x: float,\n    max_x: float,\n    center: np.ndarray,\n    radius: float,\n    bias_subspace_x: float,\n    space_prob: float,\n    density_dif: float,\n) -&gt; np.ndarray:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#description","title":"Description","text":"<p>Generates random (x, y) points using the accept/reject method based on a given probability density function (pdf).</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#parameters","title":"Parameters","text":"<ul> <li><code>pdf</code> (<code>callable</code>): The probability density function to sample from.</li> <li><code>total_points</code> (<code>int</code>): The number of points to generate.</li> <li><code>min_x</code> (<code>float</code>): The minimum x value for sampling.</li> <li><code>max_x</code> (<code>float</code>): The maximum x value for sampling.</li> <li><code>center</code> (<code>np.ndarray</code>): The coordinates of the center of the top-hat distribution.</li> <li><code>radius</code> (<code>float</code>): The radius of the top-hat region.</li> <li><code>bias_subspace_x</code> (<code>float</code>): The probability at the top of the top-hat.</li> <li><code>space_prob</code> (<code>float</code>): The probability outside the top-hat region.</li> <li><code>density_dif</code> (<code>float</code>): The scaling factor for density differences.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code>: An array of generated (x, y) points.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#generate_points_from_cls","title":"<code>generate_points_from_cls</code>","text":"<pre><code>def generate_points_from_cls(\n    pdf: callable,\n    total_points: int,\n    min_x: float,\n    max_x: float,\n    min_y: float,\n    max_y: float,\n    min_z: float,\n    max_z: float,\n    density_dif: float,\n) -&gt; np.ndarray:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#description_1","title":"Description","text":"<p>Generates random (x, y, z) points using the accept/reject method based on a given probability density function (pdf).</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#parameters_1","title":"Parameters","text":"<ul> <li><code>pdf</code> (<code>callable</code>): The probability density function to sample from.</li> <li><code>total_points</code> (<code>int</code>): The number of points to generate.</li> <li><code>min_x</code> (<code>float</code>): The minimum x value for sampling.</li> <li><code>max_x</code> (<code>float</code>): The maximum x value for sampling.</li> <li><code>min_y</code> (<code>float</code>): The minimum y value for sampling.</li> <li><code>max_y</code> (<code>float</code>): The maximum y value for sampling.</li> <li><code>min_z</code> (<code>float</code>): The minimum z value for sampling.</li> <li><code>max_z</code> (<code>float</code>): The maximum z value for sampling.</li> <li><code>density_dif</code> (<code>float</code>): The scaling factor for density differences.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code>: An array of generated (x, y, z) points.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#class-multiple_top_hat_probability","title":"Class: <code>multiple_top_hat_probability</code>","text":""},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#description_2","title":"Description","text":"<p>A class for handling the probability function of multiple top-hat-shaped subspaces within a larger spatial environment. The class calculates and retrieves probability values based on input positions.</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#methods","title":"Methods","text":""},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#__init__","title":"<code>__init__</code>","text":"<pre><code>def __init__(\n    self,\n    num_subspace: int,\n    subspace_centers: np.ndarray,\n    subspace_radius: np.ndarray,\n    density_dif: float,\n    cell: CellType,\n) -&gt; None:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#parameters_2","title":"Parameters","text":"<ul> <li><code>num_subspace</code> (<code>int</code>): The number of subspaces.</li> <li><code>subspace_centers</code> (<code>np.ndarray</code>): The centers of each subspace.</li> <li><code>subspace_radius</code> (<code>np.ndarray</code>): The radius of each subspace.</li> <li><code>density_dif</code> (<code>float</code>): The difference in density between subspaces and non-subspaces.</li> <li><code>cell</code> (<code>CellType</code>): The cell object defining the boundary.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#__call__","title":"<code>__call__</code>","text":"<pre><code>def __call__(self, position: np.ndarray, **kwargs) -&gt; float:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#description_3","title":"Description","text":"<p>Returns the probability at a given position.</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#parameters_3","title":"Parameters","text":"<ul> <li><code>position</code> (<code>np.ndarray</code>): The coordinates of the position.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#returns_2","title":"Returns","text":"<ul> <li><code>float</code>: The probability at the given position.</li> </ul>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#update_parameters","title":"<code>update_parameters</code>","text":"<pre><code>def update_parameters(\n    self,\n    num_subspace: int | None = None,\n    subspace_centers: np.ndarray | None = None,\n    subspace_radius: np.ndarray | None = None,\n    density_dif: float | None = None,\n    cell: CellType | None = None,\n) -&gt; None:\n</code></pre>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#description_4","title":"Description","text":"<p>Updates the parameters of the probability function.</p>"},{"location":"API_Documentation/core/probabilityfuncs/probability_functions/#parameters_4","title":"Parameters","text":"<ul> <li><code>num_subspace</code> (<code>int | None</code>): The number of subspaces.</li> <li><code>subspace_centers</code> (<code>np.ndarray | None</code>): The centers of each subspace.</li> <li><code>subspace_radius</code> (<code>np.ndarray | None</code>): The radius of each subspace.</li> <li><code>density_dif</code> (<code>float | None</code>): The difference in density between subspaces and non-subspaces.</li> <li><code>cell</code> (<code>CellType | None</code>): The cell object defining the boundary.</li> </ul>"},{"location":"API_Documentation/core/sample/sim_sampleplane/","title":"Sim sampleplane","text":""},{"location":"API_Documentation/core/sample/sim_sampleplane/#sim_sampleplanepy","title":"<code>sim_sampleplane.py</code>","text":"<p>This module defines classes for simulating a sample plane, including fluorescent objects, spatial indexing, and time-based tracking.</p>"},{"location":"API_Documentation/core/sample/sim_sampleplane/#constants","title":"Constants","text":"<ul> <li><code>EMPTY_STATE_HISTORY_DICT</code>: A placeholder dictionary indicating no transmittance at a given wavelength.</li> </ul>"},{"location":"API_Documentation/core/sample/sim_sampleplane/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/sample/sim_sampleplane/#fluorescentobject","title":"<code>FluorescentObject</code>","text":"<p>Represents a fluorescent object in the sample plane.</p> <ul> <li>Attributes:</li> <li><code>object_id</code>: Unique identifier for the object.</li> <li><code>position</code>: Current position (x, y, z) in \u03bcm.</li> <li><code>fluorophore</code>: <code>Fluorophore</code> instance defining the object's properties.</li> <li><code>position_history</code>: Dictionary tracking position over time.</li> <li> <p><code>state_history</code>: Dictionary tracking state history over time.</p> </li> <li> <p>Methods:</p> </li> <li><code>__post_init__()</code>: Initializes position and state history at t=0.</li> </ul>"},{"location":"API_Documentation/core/sample/sim_sampleplane/#cellspaceview","title":"<code>CellSpaceView</code>","text":"<p>Represents a 3D field of view with bounds in x, y, and z dimensions.</p> <ul> <li>Attributes:</li> <li><code>x_bounds</code>: Tuple defining the x-axis bounds.</li> <li><code>y_bounds</code>: Tuple defining the y-axis bounds.</li> <li> <p><code>z_bounds</code>: Tuple defining the z-axis bounds.</p> </li> <li> <p>Methods:</p> </li> <li><code>__post_init__()</code>: Validates that bounds have min &lt; max.</li> <li><code>contains(position: Tuple[float, float, float]) -&gt; bool</code>: Checks if a position is within the FOV.</li> <li><code>bounds</code>: Property returning the FOV bounds.</li> </ul>"},{"location":"API_Documentation/core/sample/sim_sampleplane/#samplespace","title":"<code>SampleSpace</code>","text":"<p>Represents the total 3D space available for simulation.</p> <ul> <li>Attributes:</li> <li><code>x_max</code>: Maximum x-coordinate.</li> <li><code>y_max</code>: Maximum y-coordinate.</li> <li><code>z_min</code>: Minimum z-coordinate.</li> <li> <p><code>z_max</code>: Maximum z-coordinate.</p> </li> <li> <p>Methods:</p> </li> <li><code>contains_fov(fov: CellSpaceView) -&gt; bool</code>: Checks if a FOV fits within the sample space.</li> <li><code>contains_position(position: Tuple[float, float, float]) -&gt; bool</code>: Checks if a position is within the sample space.</li> <li><code>bounds</code>: Property returning the space bounds.</li> </ul>"},{"location":"API_Documentation/core/sample/sim_sampleplane/#sampleplane","title":"<code>SamplePlane</code>","text":"<p>Manages the simulation of fluorescent objects within a sample plane.</p> <ul> <li>Attributes:</li> <li><code>_space</code>: <code>SampleSpace</code> instance defining the total simulation volume.</li> <li><code>_fov</code>: <code>CellSpaceView</code> instance defining the FOV.</li> <li><code>_objects</code>: Dictionary of <code>FluorescentObject</code> instances.</li> <li><code>_spatial_index</code>: Spatial index for fast lookup of objects.</li> <li><code>_grid_size</code>: Size of grid cells in \u03bcm.</li> <li><code>dt</code>: Time step in milliseconds.</li> <li><code>dt_s</code>: Time step in seconds.</li> <li><code>t_end</code>: End time in milliseconds.</li> <li> <p><code>time_points</code>: List of time points for simulation.</p> </li> <li> <p>Methods:</p> </li> <li><code>__init__(sample_space: SampleSpace, fov: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]], oversample_motion_time: int, t_end: int)</code>: Initializes the sample plane.</li> <li><code>add_object(object_id: str, position: Tuple[float, float, float], fluorophore: Fluorophore, trajectory: Optional[Dict[int, Tuple[float, float, float]]] = None) -&gt; bool</code>: Adds a fluorescent object to the sample plane.</li> <li><code>get_all_objects() -&gt; List[FluorescentObject]</code>: Retrieves all objects in the sample plane.</li> <li><code>get_objects_in_range(center: Tuple[float, float, float], radius: float, t: int) -&gt; List[FluorescentObject]</code>: Retrieves objects within a specified radius of a point at a given time.</li> <li><code>is_within_fov(position: Tuple[float, float, float]) -&gt; bool</code>: Checks if a position is within the FOV.</li> <li><code>_update_spatial_index(object_id: str, position: Tuple[float, float, float], t: int)</code>: Updates the spatial index for an object at a specific time.</li> <li><code>get_object(object_id: str) -&gt; Optional[FluorescentObject]</code>: Retrieves an object by its ID.</li> <li><code>__iter__() -&gt; Iterator[FluorescentObject]</code>: Makes the sample plane iterable.</li> <li><code>__len__() -&gt; int</code>: Returns the number of objects in the sample plane.</li> <li><code>_get_grid_position(position: Tuple[float, float, float]) -&gt; Tuple[int, int, int]</code>: Converts a position to grid coordinates.</li> <li><code>_distance(p1: Tuple[float, float, float], p2: Tuple[float, float, float]) -&gt; float</code>: Calculates the Euclidean distance between two points.</li> <li><code>fov_bounds</code>: Property returning the FOV bounds.</li> <li><code>sample_space_bounds</code>: Property returning the sample space bounds.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/","title":"Flurophore schema","text":""},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#flurophore_schemapy","title":"<code>flurophore_schema.py</code>","text":"<p>This module defines the schema and classes for modeling fluorophores and their properties, including wavelength-dependent spectral data, states, and state transitions.</p>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#constants","title":"Constants","text":"<ul> <li><code>CS_COEFF</code>: A constant derived from the natural logarithm of 10, multiplied by \\(\\(10^3\\)\\) and divided by Avogadro's number (\\(\\(N_A\\)\\)).</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#functions","title":"Functions","text":""},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#normalize_valuesvalues-listfloat-listfloat","title":"<code>normalize_values(values: List[float]) -&gt; List[float]</code>","text":"<p>Normalizes a list of values such that they sum to 1.</p> <ul> <li>Parameters:</li> <li><code>values</code>: A list of floats to be normalized.</li> <li>Returns: A list of normalized floats.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#classes","title":"Classes","text":""},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#wavelengthdependentbase","title":"<code>WavelengthDependentBase</code>","text":"<p>Base class for wavelength-dependent data.</p> <ul> <li>Attributes:</li> <li><code>wavelengths</code>: List of wavelengths (nm).</li> <li><code>values</code>: List of corresponding values.</li> <li> <p><code>cache_values</code>: Dictionary caching values for specific wavelengths.</p> </li> <li> <p>Methods:</p> </li> <li><code>model_post_init(__context: Any) -&gt; None</code>: Initializes the cache with values at each wavelength.</li> <li><code>validate_lengths(cls, v, info)</code>: Validates that <code>wavelengths</code> and <code>values</code> have the same length.</li> <li><code>get_value(wavelength: float) -&gt; float</code>: Retrieves or interpolates the value at a specific wavelength.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#spectraldata","title":"<code>SpectralData</code>","text":"<p>Extends <code>WavelengthDependentBase</code> for wavelength-dependent spectral data.</p> <ul> <li>Attributes:</li> <li> <p><code>values</code>: List of intensities (0-1), aliased as <code>intensities</code>.</p> </li> <li> <p>Methods:</p> </li> <li><code>get_intensity(wavelength: float) -&gt; float</code>: Retrieves the intensity at a specific wavelength.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#wavelengthdependentproperty","title":"<code>WavelengthDependentProperty</code>","text":"<p>Extends <code>WavelengthDependentBase</code> for wavelength-dependent properties.</p>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#statetype","title":"<code>StateType</code>","text":"<p>Enum class representing types of fluorophore states.</p> <ul> <li>Values:</li> <li><code>FLUORESCENT</code>: Fluorescent state.</li> <li><code>DARK</code>: Dark state.</li> <li><code>BLEACHED</code>: Bleached state.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#state","title":"<code>State</code>","text":"<p>Represents a single state of a fluorophore.</p> <ul> <li>Attributes:</li> <li><code>name</code>: Name of the state.</li> <li><code>state_type</code>: Type of the state (from <code>StateType</code>).</li> <li><code>excitation_spectrum</code>: Optional <code>SpectralData</code> for excitation.</li> <li><code>emission_spectrum</code>: Optional <code>SpectralData</code> for emission.</li> <li><code>quantum_yield_lambda_val</code>: Optional quantum yield at a specific wavelength (0-1).</li> <li><code>quantum_yield</code>: Optional wavelength-dependent quantum yield.</li> <li><code>extinction_coefficient_lambda_val</code>: Optional extinction coefficient at a specific wavelength (M\u207b\u00b9cm\u207b\u00b9).</li> <li><code>extinction_coefficient</code>: Optional wavelength-dependent extinction coefficient.</li> <li><code>ex_max</code>: Wavelength (nm) at maximum excitation.</li> <li><code>em_max</code>: Wavelength (nm) at maximum emission.</li> <li><code>molar_cross_section</code>: Optional wavelength-dependent molar cross-section.</li> <li><code>fluorescent_lifetime</code>: Optional fluorescent lifetime (1/s).</li> <li> <p><code>fluorescent_lifetime_inverse</code>: Inverse of fluorescent lifetime.</p> </li> <li> <p>Methods:</p> </li> <li><code>model_post_init(__context)</code>: Initializes derived properties like <code>ex_max</code>, <code>em_max</code>, and expands values to spectra.</li> <li><code>_val_ratio_expand(val: float, wavelength: float, base_spectrum: WavelengthDependentBase) -&gt; WavelengthDependentProperty</code>: Expands a value to a spectrum based on a ratio.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#statetransition","title":"<code>StateTransition</code>","text":"<p>Represents a transition between states.</p> <ul> <li>Attributes:</li> <li><code>from_state</code>: Name of the starting state.</li> <li><code>to_state</code>: Name of the target state.</li> <li><code>spectrum</code>: Optional <code>SpectralData</code> for the activation spectrum.</li> <li><code>extinction_coefficient_lambda_val</code>: Optional extinction coefficient at a specific wavelength (M\u207b\u00b9cm\u207b\u00b9).</li> <li><code>extinction_coefficient</code>: Optional wavelength-dependent extinction coefficient.</li> <li><code>cross_section</code>: Optional wavelength-dependent cross-section.</li> <li><code>base_rate</code>: Optional base transition rate (1/s).</li> <li> <p><code>quantum_yield</code>: Optional quantum yield for state change.</p> </li> <li> <p>Methods:</p> </li> <li><code>model_post_init(__context)</code>: Initializes derived properties like <code>extinction_coefficient</code> and <code>cross_section</code>.</li> <li><code>rate() -&gt; Callable</code>: Returns a function to calculate the activation rate at a specific wavelength and intensity.</li> <li><code>_val_ratio_expand(val: float, wavelength: float, base_spectrum: WavelengthDependentBase) -&gt; WavelengthDependentProperty</code>: Expands a value to a spectrum based on a ratio.</li> </ul>"},{"location":"API_Documentation/core/sample/flurophore/flurophore_schema/#fluorophore","title":"<code>Fluorophore</code>","text":"<p>Represents a complete fluorophore model.</p> <ul> <li>Attributes:</li> <li><code>name</code>: Name of the fluorophore.</li> <li><code>states</code>: Dictionary of states, keyed by state name.</li> <li><code>transitions</code>: Dictionary of state transitions.</li> <li> <p><code>initial_state</code>: The initial state of the fluorophore.</p> </li> <li> <p>Methods:</p> </li> <li><code>validate_states(cls, v)</code>: Validates that at least one state is fluorescent and state names are unique.</li> <li><code>validate_transitions(cls, v, info)</code>: Validates that transitions reference valid states.</li> <li><code>_find_transitions(statename: str) -&gt; List[StateTransition]</code>: Finds all transitions originating from a specific state.</li> </ul>"},{"location":"API_Documentation/utils/constants/","title":"Constants","text":""},{"location":"API_Documentation/utils/constants/#constantspy","title":"<code>constants.py</code>","text":""},{"location":"API_Documentation/utils/constants/#constants","title":"Constants","text":""},{"location":"API_Documentation/utils/constants/#n_a","title":"<code>N_A</code>","text":"<pre><code>N_A = 6.02214076e23  # Avogadro's number\n</code></pre> <ul> <li>Description: Avogadro's number, representing the number of particles (atoms, molecules, ions, etc.) in one mole of a substance.</li> </ul>"},{"location":"API_Documentation/utils/constants/#c_light_m_s","title":"<code>C_LIGHT_M_S</code>","text":"<pre><code>C_LIGHT_M_S = 299792458  # Speed of light in m/s\n</code></pre> <ul> <li>Description: The speed of light in a vacuum, measured in meters per second.</li> </ul>"},{"location":"API_Documentation/utils/constants/#k_boltzmann","title":"<code>K_BOLTZMANN</code>","text":"<pre><code>K_BOLTZMANN = 1.380649e-23  # Boltzmann constant in J/K\n</code></pre> <ul> <li>Description: The Boltzmann constant, relating the average kinetic energy of particles in a gas to the temperature of the gas.</li> </ul>"},{"location":"API_Documentation/utils/constants/#h_planck","title":"<code>H_PLANCK</code>","text":"<pre><code>H_PLANCK = 6.62607015e-34  # Planck constant in J*s\n</code></pre> <ul> <li>Description: The Planck constant, a fundamental constant in quantum mechanics.</li> </ul>"},{"location":"API_Documentation/utils/constants/#h_c_com","title":"<code>H_C_COM</code>","text":"<pre><code>H_C_COM = 0.1 / (H_PLANCK * C_LIGHT_M_S)\n</code></pre> <ul> <li>Description: A derived constant calculated as <code>0.1 / (H_PLANCK * C_LIGHT_M_S)</code>.</li> </ul>"},{"location":"API_Documentation/utils/errors/","title":"Errors","text":""},{"location":"API_Documentation/utils/errors/#errorspy","title":"<code>errors.py</code>","text":""},{"location":"API_Documentation/utils/errors/#exceptions","title":"Exceptions","text":""},{"location":"API_Documentation/utils/errors/#hurstvalueerror","title":"<code>HurstValueError</code>","text":"<pre><code>class HurstValueError(Exception):\n    \"\"\"Raised when the Hurst value is not within the range (0, 1)\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when the Hurst value provided is not within the valid range of 0 to 1.</li> </ul>"},{"location":"API_Documentation/utils/errors/#spacelimiterror","title":"<code>SpaceLimitError</code>","text":"<pre><code>class SpaceLimitError(Exception):\n    \"\"\"Raised when the space limit is not within the range (-inf, inf)\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when the space limit provided is not within the valid range of negative infinity to positive infinity.</li> </ul>"},{"location":"API_Documentation/utils/errors/#diffusionhigherror","title":"<code>DiffusionHighError</code>","text":"<pre><code>class DiffusionHighError(Exception):\n    \"\"\"Raised when the diffusion value is too high for the space limit\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when the diffusion value provided is too high relative to the space limit.</li> </ul>"},{"location":"API_Documentation/utils/errors/#hursthigherror","title":"<code>HurstHighError</code>","text":"<pre><code>class HurstHighError(Exception):\n    \"\"\"Raised when the Hurst value is too high for the space limit\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when the Hurst value provided is too high relative to the space limit.</li> </ul>"},{"location":"API_Documentation/utils/errors/#configvalidationerror","title":"<code>ConfigValidationError</code>","text":"<pre><code>class ConfigValidationError(Exception):\n    \"\"\"Exception raised for errors in the configuration validation.\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when there is an error in the validation of the configuration settings.</li> </ul>"},{"location":"API_Documentation/utils/errors/#configconversionerror","title":"<code>ConfigConversionError</code>","text":"<pre><code>class ConfigConversionError(Exception):\n    \"\"\"Exception raised for errors in the configuration conversion process.\"\"\"\n    pass\n</code></pre> <ul> <li>Description: This exception is raised when there is an error in the conversion process of the configuration settings.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/","title":"Util functions","text":""},{"location":"API_Documentation/utils/util_functions/#util_functionspy","title":"<code>util_functions.py</code>","text":"<p>This module provides utility functions for various operations such as array conversion, image saving, binning, subsegmentation, and directory structure creation.</p>"},{"location":"API_Documentation/utils/util_functions/#functions","title":"Functions","text":""},{"location":"API_Documentation/utils/util_functions/#convert_arrays_to_lists","title":"<code>convert_arrays_to_lists</code>","text":"<pre><code>def convert_arrays_to_lists(obj: np.ndarray | dict) -&gt; list | dict:\n    \"\"\"\n    Recursively convert NumPy arrays to lists.\n\n    Parameters:\n    -----------\n    obj : np.ndarray | dict\n        Object to be converted.\n\n    Returns:\n    --------\n    list | dict\n        Converted object with NumPy arrays replaced by lists.\n    \"\"\"\n</code></pre> <ul> <li>Description: This function recursively converts NumPy arrays within a given object (either a NumPy array or a dictionary containing arrays) to lists.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#convert_lists_to_arrays","title":"<code>convert_lists_to_arrays</code>","text":"<pre><code>def convert_lists_to_arrays(obj: list | dict) -&gt; np.ndarray | dict:\n    \"\"\"\n    Recursively convert lists to NumPy arrays.\n\n    Parameters:\n    -----------\n    obj : list | dict\n        Object to be converted.\n\n    Returns:\n    --------\n    np.ndarray | dict\n        Converted object with lists replaced by NumPy arrays.\n    \"\"\"\n</code></pre> <ul> <li>Description: This function recursively converts lists within a given object (either a list or a dictionary containing lists) to NumPy arrays.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#save_tiff","title":"<code>save_tiff</code>","text":"<pre><code>def save_tiff(\n    image: np.ndarray, path: str, img_name: str | None = None, tifffile_args: dict = {}\n) -&gt; None:\n    \"\"\"\n    Save the image as a TIFF file.\n\n    Parameters:\n    -----------\n    image : np.ndarray\n        Image to be saved.\n    path : str\n        Path where the image will be saved.\n    img_name : str, optional\n        Name of the image file (without extension), by default None.\n    tifffile_args: dict(str, val)\n        named arguments passed to the tifffile plugin as a dict.\n\n    Returns:\n    --------\n    None\n    \"\"\"\n</code></pre> <ul> <li>Description: This function saves a given image as a TIFF file to the specified path. It optionally allows for additional arguments to be passed to the <code>tifffile</code> plugin.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#binning_array","title":"<code>binning_array</code>","text":"<pre><code>def binning_array(\n    array_to_bin: np.ndarray, binning_size: int, mode: str = \"sum\"\n) -&gt; np.ndarray:\n    \"\"\"\n    Bin an N-dimensional array by summing values in each bin.\n\n    Parameters:\n    -----------\n    array_to_bin: numpy.ndarray\n        Input N-dimensional array to be binned\n    binning_size : int\n        Size of the binning window (e.g., 2 for 2x2 binning)\n    mode : str, optional\n        Method for binning. Currently only supports 'sum'\n\n    Returns:\n    --------\n    numpy.ndarray\n        Binned array with reduced dimensions\n    \"\"\"\n</code></pre> <ul> <li>Description: This function performs binning on an N-dimensional array by summing the values within each bin. The binning size determines the window size for binning.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#sub_segment","title":"<code>sub_segment</code>","text":"<pre><code>def sub_segment(\n    img: np.ndarray,\n    subsegment_num: int,\n    img_name: str | None = None,\n    subsegment_type: str = \"mean\",\n) -&gt; list[np.ndarray]:\n    \"\"\"\n    Perform subsegmentation on the image.\n\n    Parameters:\n    -----------\n    img : np.ndarray\n        Image to be subsegmented.\n    subsegment_num : int\n        Number of subsegments to be created.\n    img_name : str, optional\n        Name of the image, by default None.\n    subsegment_type : str, optional\n        Type of subsegmentation to be performed. Options are \"mean\", \"max\", \"std\". Default is \"mean\".\n\n    Returns:\n    --------\n    list[np.ndarray]\n        List of subsegmented images.\n\n    Raises:\n    -------\n    ValueError\n        If the subsegment type is not supported.\n    \"\"\"\n</code></pre> <ul> <li>Description: This function performs subsegmentation on an image by dividing it into the specified number of subsegments and applying the chosen subsegmentation type (mean, max, or standard deviation).</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#make_directory_structure","title":"<code>make_directory_structure</code>","text":"<pre><code>def make_directory_structure(\n    cd: str,\n    img_name: str,\n    img: np.ndarray,\n    subsegment_type: str,\n    subsegment_num: int,\n    **kwargs,\n) -&gt; list[np.ndarray]:\n    \"\"\"\n    Create the directory structure for the simulation, save the image, and perform subsegmentation.\n\n    Parameters:\n    -----------\n    cd : str\n        Directory where the simulation will be saved.\n    img_name : str\n        Name of the image.\n    img : np.ndarray\n        Image to be subsegmented.\n    subsegment_type : str\n        Type of subsegmentation to be performed.\n    subsegment_num : int\n        Number of subsegments to be created.\n    **kwargs : dict\n        Additional keyword arguments, including:\n        - data : dict (optional)\n            Dictionary of data to be saved, keys are \"map\", \"tracks\", \"points_per_frame\".\n        - parameters : dict (optional)\n            Parameters of the simulation to be saved.\n\n    Returns:\n    --------\n    list[np.ndarray]\n        List of subsegmented images.\n\n    Raises:\n    -------\n    None\n    \"\"\"\n</code></pre> <ul> <li>Description: This function creates the directory structure for a simulation, saves the image, and performs subsegmentation. It also saves additional data and parameters if provided.</li> </ul>"},{"location":"API_Documentation/utils/util_functions/#ms_to_seconds","title":"<code>ms_to_seconds</code>","text":"<pre><code>@cache\ndef ms_to_seconds(time: int | float) -&gt; float:\n    return time * 1e-3\n</code></pre> <ul> <li>Description: This function converts a time value from milliseconds to seconds. The <code>@cache</code> decorator is used to cache the result for faster access if the same input is provided again.</li> </ul>"}]}